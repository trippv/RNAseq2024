[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "texto de prueba"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RNAseq2024",
    "section": "",
    "text": "Date: Date and time\nLugar: Centro de Investigaciones Biológicas del Noroeste, S.C.\nInstructores: Miguel A. Tripp Valdez, Pavel E. Galindo Torres"
  },
  {
    "objectID": "index.html#temario-del-curso",
    "href": "index.html#temario-del-curso",
    "title": "RNAseq2024",
    "section": "Temario del curso",
    "text": "Temario del curso\n\nMÓDULO I: Introducción a R base\n1.1 Conceptos básicos (La consola en R y Rstudio, ejecutar, llamar, correr y devolver, objetos, constantes y variables, funciones, documentación, directorio de trabajo, sesión, paquetes y scripts).\n1.2 Tipos de datos (Numérico, entero, carácter, factor, lógico, nulo, NA).\n1.3 Operadores (Aritméticos, relacionales, lógicos y de asignación).\n1.4 Estructuras de datos (Vectores, matríces, arreglos, marcos de datos, listas y coerción).\n1.5 Subconjuntos (vectores, matrices y listas).\n1.6 Funciones básicas (getwd(), setwd(), length(), sort(), min(), max(), c(), seq(), t(), mean(), sd(), sum(), etc.).\n1.7 Importar y exportar datos.\n1.7 Instalar y cargar librerias\n1.7 Creación de proyectos en Rstudio\n\n\nMÓDULO II: Introducción a GNU/Linux\n2.1 Breve historia de GNU/Linux, conociendo la terminal.\n2.2 Comandos básicos.\n2.3 Flujos de control básicos (if-else, for, while).\n2.4 Gestionadores de paquetes.\n2.5 Instalación de paquetes y manejo de ambientes conda (conda, miniconda, homebrew).\n2.6 Acceso a servidores remotos.\n\n\nModulo IV: Análisis de datos de lecturas cortas (Illumina).\n4.1 Introducción a las tecnologías de secuenciación modernas.\n4.2 Control de calidad de datos (Tipos de datos, FastQC/MultiQC).\n4.3 Corte de secuencias (Trimmomatic, cutadapt, fastx-toolkit).\n4.4 Ensamble con genoma guiado y de novo (Trinity).\n4.5 Valoración del ensamble (Transrate, BUSCO).\n4.6 Análisis de genes expresados diferencialmente (Alineamiento de lecturas y estimación de la abundancia, análisis de genes y transcritos expresados diferencialmente: EdgeR, Visualización de resultados).\n4.7 Anotación funcional con trinotate (BLAST, Ontología de genes, análisis de enriquecimientos funcionales (GO, KEGG), Reactome, etc.\n4.8 Análisis de redes de proteínas (STRING)."
  },
  {
    "objectID": "1_control_calidad.html",
    "href": "1_control_calidad.html",
    "title": "Control de Calidad",
    "section": "",
    "text": "Moverse a la carpeta curso2022 y crear carpeta de trabajo Transcriptomica y acceder.\ncd curso2020\nmkdir Transcriptomica \ncd Transcriptomica"
  },
  {
    "objectID": "1_control_calidad.html#lecturas-de-prueba",
    "href": "1_control_calidad.html#lecturas-de-prueba",
    "title": "Control de Calidad",
    "section": "Lecturas de prueba",
    "text": "Lecturas de prueba\nAntes de análizar las secuencias de nuestro estudio, vamos a ver unos ejemplos de cálidad de secuencias. Estas secuencias se obtuvieron de bases de datos publicas. Ojo: Estas lecturas solo son una submuestra de las originales, por lo que son mucho mas pequeñas.\n\nCreamos una carpeta parental llamada FASTQC_TEST y dentro de esta, generamos las carpetas secuencias, FASTQC_PRE y FASTQC_POST.\n\n\nmkdir -p fastqc_test/{secuencias,fastqc_pre,fastqc_post}\n\n\nDentro de la carpeta secuenciasvamos a crear un link simbólico de las secuencias que serán utilizadas.\n\n\nRecuerda la sintaxis ln -s ORIGEN DESTINO\n\n\ncd fastqc_test/secuencias\n\n ln -s /LUSTRE/bioinformatica_data/genomica_funcional/Tripp/Curso_2022/FASTQC_test/secuencias/*.fastq ./\nls\n\n\n\n\n\n\n\nWarning\n\n\n\n\nPregunta: ¿Como sabe cuantas lecturas tiene cada archivo?\n\nPodemos utilizar la función grep para buscar un caracter en común de todas las lecturas y hacer pipe para contar el número de lineas que tienen ese caracter\nPor ejemplo: las lectutas SRR7096024_1.fastq, podemos utilizar el ID @SRR7096024_1\n\ncat SRR7096024_1.fastq | grep \"^@SRR70\" | wc -l\n\n\n\n\n:::info Manejador de tareas SLURM\nDentro del curso, muchos de los procesos que se correrar son muy demantantes en cuanto a poder computacional, por lo que para evitar que el cluster colapse, se utiliza un manejador de tareas el cual nos asigna los recursos necesarios cuando haya disponibilidad.\nEn el curso utilizaremos el manejador de tareas de dos formas:\n\nUtilizando archivos ejecutables (slrm) Estos archivos continenen todas las instrucciones para poder correr un programa tal como el nombre de la cola, la cantidad de memoria y numero de nucleos que se requiere asi como los nombres del output. Un ejemplo del formato de estos archivos es:\n\n\n#!/bin/bash \n#SBATCH -p cicese\n#SBATCH --job-name=fastqc\n#SBATCH --output=fastqc-%j.log\n#SBATCH --error=fastqc-%j.err\n#SBATCH -N 1\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n\n#Resto de las instrucciones\n\n\nUtilizando el script accesa-nodo el cual te asignara un nodo durante el tiempo que estemos trabajando. Es importante que cada que termines la sesión te desconectes del nodo (exit) ya que seguiras ocupando espacio aún si no estas haciendo nada\n\n::: —\n\nPosteriormente ejecutamos FASTQC. Para esto nos vamos a colocar en la carpeta fastqc_pre y generamos el siguiente slrm\n\n\n#!/bin/bash\n#SBATCH -p cicese\n#SBATCH --job-name=fastqc\n#SBATCH --output=fastqc-%j.log\n#SBATCH --error=fastqc-%j.err\n#SBATCH -N 1\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n\n\n# Exportar la ruta de FastQC_v0.11.7\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/FastQC_v0.11.7\n\nfastqc ../secuencias/*.fastq -t 8 -o ./\n\n\nDescargamos los reportes HTML generados a nuestra computadora en la carpeta de trabajo para revisarlo. Para esto, abrimos una nueva ventana de la terminal y vamos a generar una carpeta llamada FASTQC_TEST\n\n\n$LAPTOP-NNNNN:$mkdir -p FASTQC_TEST/{FASTQC_PRE,FASTQC_POST}\n\ncd FASTQC_TEST/FASTQC_PRE\n\n\nRecuerda la sintaxis: $scp curso##@omica:ruta/de/la/carpeta/*.html ./\n\n\nRevisión individual de archivos .html en navegador firefox o en el navegador que tengan instalado, para verificar la calidad de las lecturas de secuenciación.\n\nfirefox SRR10858532_1_fastqc.html\nfirefox SRR10858532_2_fastqc.html\n\n:bulb: NOTA: Si estas utilizando ubuntu app, dentro de la carpeta de trabajo ejecuta\n$explorer.exe SRR10858532_1_fastqc.html\n\n\nRevisa cada uno de los reportes y discute cuales son las diferencias entre la calidad de las lecturas"
  },
  {
    "objectID": "1_control_calidad.html#limpieza-y-control-de-calidad-de-las-lecturas",
    "href": "1_control_calidad.html#limpieza-y-control-de-calidad-de-las-lecturas",
    "title": "Control de Calidad",
    "section": "2. Limpieza y control de calidad de las lecturas",
    "text": "2. Limpieza y control de calidad de las lecturas\nAhora utilizaremos el Programa Trimmomatic para cortar y filtrar las lecturas con baja calidad asi como eliminar adaptadores que puderan haber permanecido en la lecturas\n\nDentro de tu carpeta de fastqc_test en OMICA, crear la carpeta Trimmomatic en la carpeta Transcriptomica y acceder a ella.\n\nCrear la carpeta TRIMMOMATIC en la carpeta Transcriptomica y acceder a ella.\n\ncd ..\nmkdir trimmomatic\ncd trimmomatic\n\n\nGenerar el script al cual llamaremos 2.trimmomatic.slrm\n\n\nnano 2.trimmomatic.slrm\n\nEl slrm debe contener lo siguiente:\n\n\n#!/bin/bash\n#########################################################\n#TRIMOMMATIC\n\n## Directivas\n#SBATCH --job-name=qtrim\n#SBATCH --output=trimmomatic-%j.log\n#SBATCH --error=trimmomatic-%j.err\n#SBATCH -N 1\n#SBATCH --mem=20GB\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n#SBATCH -p cicese\n\n\n# Ruta a TRIMMOMATIC\nTRIMMOMATIC=/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trimmomatic-0.36\n\n#Ruta al archivo con los adaptadores\ntrueseq=\"$TRIMMOMATIC/adapters/TruSeq3-PE-2.fa\"\n\n\n\ncd ${SLURM_SUBMIT_DIR}\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../secuencias/SRR7096024_1.fastq ../secuencias/SRR7096024_2.fastq -baseout trimmed_SRR7096024.fastq \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../secuencias/SRR10858532_1.fastq ../secuencias/SRR10858532_2.fastq -baseout trimmed_SRR10858532.fastq \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../secuencias/rv06m_S8_L001_subset_1.fastq ../secuencias/rv06m_S8_L001_subset_2.fastq -baseout trimmed_rv06m_S8_L001.fastq \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\n\nexit 0\n\n\nCorrer el script trimmomatic.slrm\n\n\nsbatch 2.trimmomatic.slrm\nsqueue\n\n\nGenerar dos carpetas para colocar las lecturas Paired y las Unpaired. Posteriormente, mueve todas las lecturas a sus respectivas carpetas usando el comando mv\n\n\nmkdir TRIMM_U TRIMM_P\n\nmv *P.fastq TRIMM_P/\nmv *U.fastq TRIMM_U/\n\n\nAhora evalua la calidad de estas lecturas limpias con FastQC dentro de la carpeta FASTQC_TEST/FASTQC_POST. Para esto, puedes generar un nuevo archivo slrm para usar FastQC\n\n\n#!/bin/bash\n#SBATCH -p cicese\n#SBATCH --job-name=fastqc\n#SBATCH --output=fastqc-%j.log\n#SBATCH --error=fastqc-%j.err\n#SBATCH -N 1\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n\n\n# Exportar la ruta de FastQC_v0.11.7\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/FastQC_v0.11.7\n\n\nfastqc ../trimmomatic/TRIMM_P/*.fastq -t 8 -o ./\n\n\nFinalmente, transfiere los reportes nuevos a tu computadora para revisarlos\nAhora vamos a repetir los pasos del 3 al 7 pero con la misma muestra pero usando parametros mas riguroso:\nGenerar el script al cual llamaremos trimmomatic_rig.slrm\n\n\nnano run_trimmomatic_rig.slrm\n\nEl slrm debe contener lo siguiente:\n\n#!/bin/sh\n\n###Directivas\n\n#SBATCH -p cicese\n#SBATCH --job-name=trimmomatic\n#SBATCH --output=trimmomatic-%j.log\n#SBATCH --error=trimmomatic-%j.err\n#SBATCH -N 1\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 06-00:00:00\n\n\nTRIM=/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trimmomatic-0.36\n\ncd ${SLURM_SUBMIT_DIR}\n\njava -jar $TRIM/trimmomatic-0.36.jar PE ../SRR7096024_1.fastq ../SRR7096024_2.fastq -baseout trimmed_rig_SRR7096024.fastq \\\nILLUMINACLIP:TruSeq3-PE-2.fa:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:20 MINLEN:36 HEADCROP:5\n\nexit 0\n\nTransfiere los archivos a tu computadora para visualizarlos. Discute los principales cambios\n\nFinalmente, corre los pasos del 3 al 7 incluyendo todas las muestras."
  },
  {
    "objectID": "1_control_calidad.html#análisis-de-calidad-de-las-lecturas-con-fastqc-y-multiqc",
    "href": "1_control_calidad.html#análisis-de-calidad-de-las-lecturas-con-fastqc-y-multiqc",
    "title": "Control de Calidad",
    "section": "2.1 Análisis de calidad de las lecturas con FastQC y MultiQC",
    "text": "2.1 Análisis de calidad de las lecturas con FastQC y MultiQC\n\nFASTQC\nEn la carpeta de transcriptomica, crear carpeta FASTQC y con las subcarpetas FASTQC_PRE y FASTQC_POST. Acceder a carpeta FASTQC_PRE\n\ncd ..\nmkdir -p FASTQC/{FASTQC_PRE,FASTQC_POST}\ncd FASTQC/FASTQC_PRE/\n\nRealizar análisis de calidad de las secuencias con el programa FastQC. Se obtendrán N archivos .html y fastqc.zip . Sintaxis fastqc [-t # ] [path to file] [-o output dir]\n\n\n\n\n\n\nWarning\n\n\n\nNOTA: Para realizar este paso es posible utilizar el script accesa-nodo para solicitar un nodo en el cluster sin necesidad de hacer un archivo slurm\n\n\n\nfastqc -t 8 ../../RAW_READS/*.fastq.gz -o ./    \n\n\nls      \n\nA continuación, vamos a importar los archivos .html a nuestra PC. Para ello sigan las instrucciones siguientes:\nPaso 1. Abrir una nueva terminal para Paso 2. Acceder a nuestra carpeta de transcrptomica\n\n$ cd Documentos/curso2022/transrciptomica\n\nPaso 3. Crear en transcriptomica un directorio con el nombre FASTQC y dentro de él, dos que se llamen FASTQC_PRE y FASTQC_POST.\n\n$ mkdir -p FASTQC/{FASTQC_PRE,FASTQC_POST}\n\nPaso 4. Acceder al directorio FASTQC_PRE\n\n$ cd FASTQC_PRE\n\nPaso 5. Copiar dentro de este directorio todos los archivos .html que generamos en el cluster.\n\n$ scp curso01@omica:/home/curso01/curso2022/trascriptomica/FASTQC/FASTQC_PRE/*.html ./\n\nPaso 6. Revisión individual de archivos .html en navegador firefox o en el navegador que tengan instalado, para verificar la calidad de las lecturas de secuenciación.\n\n$ firefox Ctrl_rep1_500k_R1_fastqc.html \n\n\n:bulb: Si estas trabajando con Ubuntu app, puedes buscar directamente los archivos en la carpeta, pero si deseas abrir chrome directamente de la terminal ejecuta la siguiente linea:\n\nexport chrome=“/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe”\n\n\n\nMULTIQC\nSi se quiere hacer una comparación entre todos los valores de calidad de las secuencias, se puede utilizar el programa MultiQC que utiliza los archivos generados por FastQC. Se requiere un ambiente para el programa que está basado en python 2.7\n\n\n\n\n\n\nWarning\n\n\n\nPara poder utilizar MultiQC es necesario cargar el modulo de python 2.7 y posteriormente activar el ambiente donde esta MultiQC\n\n\n# Para cargar el ambiente conda\n$ module load python-2.7-anaconda       \n\n# Activar ambiente\n$ source activate multiqc_py2.7                 \n\n# Para desactivar ambiente:\n$ source deactivate multiqc_py2.7                   \n\n\n\nDentro de la carpeta de FASTQ_PRE crear una carpeta llamada MULTIQC. Entramos a esta carpeta y corremos MultiQC activando el ambiente multiqc_py2.7. Se generaran las carpetas multiqc_data, multiqc_plots y multiqc_reports.html. Revisar archivo .html. Al finalizar desactivar el ambiente multiqc_py2.7.\n\n$ mkdir MULTIQC\n$ cd MULTIQC/\n$ multiqc ../*.zip -o ./ --data-format tsv --export --title \"Analisis pre trimming\"\n\n\n$ source deactivate multiqc_py2.7\n\nRevisar el archivo .html obtenido con MultiQC dentro de la carpeta PRE y descargarlo a su computadora personal siguiendo los pasos descritos anteriormente\n\n\ncd Documentos/curso2022/transrciptomica/FASTQC_PRE\nmkdir Multiqc\ncd Multiqc\nscp curso01@omica:/home/curso01/curso2022/trascriptomica/FASTQC/FASTQC_PRE/Multiqc/multiqc_report.html ./\n   \n\n3. Revisar el archivo .hmtl obtenido con el programa MultiQC\n\nfirefox multiqc_report.html\n\n4. Cerrar esta terminal en cuanto se termine de revisar el archivo .html"
  },
  {
    "objectID": "1_control_calidad.html#limpieza-y-eliminación-de-lecturas-de-mala-calidad-con-trimmomatic",
    "href": "1_control_calidad.html#limpieza-y-eliminación-de-lecturas-de-mala-calidad-con-trimmomatic",
    "title": "Control de Calidad",
    "section": "2.2. Limpieza y eliminación de lecturas de mala calidad con Trimmomatic",
    "text": "2.2. Limpieza y eliminación de lecturas de mala calidad con Trimmomatic\n\n\n\n\n\n\nWarning\n\n\n\nComo utilizaremos trimmomatic con un archivo slurm en este punto debes salir del nodo\n\n\nEn este paso se usará el programa Trimmomatic, para eliminar las secuencias de mala calidad, así como índices o adaptadores de secuenciación que pudieran haber quedado.\nCrear la carpeta TRIMMOMATIC en la carpeta transcriptomica y acceder a ella.\n\ncd ../../\nmkdir TRIMMOMATIC\ncd TRIMMOMATIC\n\nGenerar el script al cual llamaremos trimmomatic.slrm\n\nnano trimmomatic.slrm\n\nEl slrm debe contener lo siguiente:\n\n#!/bin/bash\n#########################################################\n#TRIMOMMATIC\n\n## Directivas\n#SBATCH --job-name=qtrim\n#SBATCH --output=trimmomatic-%j.log\n#SBATCH --error=trimmomatic-%j.err\n#SBATCH -N 1\n#SBATCH --mem=20GB\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n#SBATCH -p cicese\n\n\n# Ruta a TRIMMOMATIC\nTRIMMOMATIC=/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trimmomatic-0.36\n\n#Ruta al archivo con los adaptadores\ntrueseq=\"$TRIMMOMATIC/adapters/TruSeq3-PE-2.fa\"\n\n\ncd ${SLURM_SUBMIT_DIR}\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/Ctrl_rep1_500k_R1.fastq.gz ../RAW_READS/Ctrl_rep1_500k_R2.fastq.gz -baseout Ctrl_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/Ctrl_rep2_500k_R1.fastq.gz ../RAW_READS/Ctrl_rep2_500k_R2.fastq.gz -baseout Ctrl_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T1_rep1_500k_R1.fastq.gz ../RAW_READS/T1_rep1_500k_R2.fastq.gz -baseout T1_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T1_rep2_500k_R1.fastq.gz ../RAW_READS/T1_rep2_500k_R2.fastq.gz -baseout T1_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T2_rep1_500k_R1.fastq.gz ../RAW_READS/T2_rep1_500k_R2.fastq.gz -baseout T2_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T2_rep2_500k_R1.fastq.gz ../RAW_READS/T2_rep2_500k_R2.fastq.gz -baseout T2_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T3_rep1_500k_R1.fastq.gz ../RAW_READS/T3_rep1_500k_R2.fastq.gz -baseout T3_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T3_rep2_500k_R1.fastq.gz ../RAW_READS/T3_rep2_500k_R2.fastq.gz -baseout T3_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\nexit 0\n\nCorrer el script trimmomatic.slrm\n\nsbatch trimmomatic.slrm\nsqueue\n\nCrear carpetas TRIM_P y TRIM_U y mover los archivos que correspondan a cada carpeta.\n\nls \nmkdir TRIM_P TRIM_U\nmv *U.fastq.gz TRIM_U/\nmv *P.fastq.gz TRIM_P/\nls \nls TRIM_P/\n\nAhora se recomienda revisar las secuencias pareadas con FastQC y MultiQC como se realizó en los pasos anteriores. Para ello deben moverse a la carpeta FASTQC_POST para correr el script.\n\ncd ../FASTQC/FASTQC_POST/\nfastqc -t 8 ../../TRIMMOMATIC/TRIM_P/*.fastq.gz -o ./               \nls \n\nCorrer el script de MultiQC en la carpeta respectiva y checar archivo .html\n\ncd ../../MULTIQC/POST\nsource activate multiqc_py2.7\nmultiqc ../../FASTQC/FASTQC_POST/*.zip -o ./ --data-format json --export\n\n\nsource deactivate multiqc_py2.7\n\nRevisar el archivo .html obtenido con MultiQC dentro de la carpeta POST.\nCerrar esta terminal en cuanto se termine de revisar el archivo .html\n\nEn caso de haber problemas con las rutas de los programas, se puede generar un bash_profile con las rutas de todos los programas:\nPegar en el .bash_profile los paths de los programas que serán utilizados durante el curso.\n\nnano .bash_profile\n\nPegar los siguientes path de los programas que serán utilizados durante el análisis transcriptómico.\n\n# Software for transcriptomic analysis\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/FastQC_v0.11.7\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trimmomatic-0.36\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/util\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/Analysis/DifferentialExpression\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/trinity-plugins/parafly-code/bin\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/trinity-plugins/parafly/bin\nexport R_LIBRARY_PATH=/LUSTRE/apps/R-3.3.1/lib64/R/library\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/ncbi-blast-2.4.0+/bin\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/TransDecoder-3.0.1\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/RNA/ricardo/bioinformatics/transdecoder\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/signalp-4.1\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/tmhmm-2.0c/bin\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trinotate/util/rnammer_support\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/rnammer\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/hmmer-3.1b2-linux-intel-x86_64/binaries\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/Trinotate/PerlLib\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/Trinotate/auto\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/samtools-1.7/bin\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/bowtie2\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/RSEM\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/Laura/bin/transrate-1.0.3-linux-x86_64/transrate\n\nActualizar el archivo .bash_profile\n\nsource .bash_profile"
  },
  {
    "objectID": "walkthrough.html",
    "href": "walkthrough.html",
    "title": "Hello, Quarto",
    "section": "",
    "text": "Markdown is an easy to read and write text format:\n\nIt’s plain text so works well with version control\nIt can be rendered into HTML, PDF, and more\nLearn more at: https://quarto.org/docs/authoring/"
  },
  {
    "objectID": "walkthrough.html#code-cell",
    "href": "walkthrough.html#code-cell",
    "title": "Hello, Quarto",
    "section": "Code Cell",
    "text": "Code Cell\nHere is a Python code cell:\n\nimport os\nos.cpu_count()\n\n8"
  },
  {
    "objectID": "walkthrough.html#equation",
    "href": "walkthrough.html#equation",
    "title": "Hello, Quarto",
    "section": "Equation",
    "text": "Equation\nUse LaTeX to write equations:\n\\[\n\\chi' = \\sum_{i=1}^n k_i s_i^2\n\\]"
  },
  {
    "objectID": "apoyo.html",
    "href": "apoyo.html",
    "title": "Recursos de apoyo",
    "section": "",
    "text": "A continuación encontrarás diversos manuales y materiales disponibles en la red con la que puedes ampliar lo visto en clase\n\nManuales\n\nTrinity RNAseq wiki - Sitio de Trinity\nTrinotate - Sitio de Trinotate\nFastQC - Sitio de Fastqc\nTrimmomatic - Manual de Trimmomatic\n\nLibros en línea\n\nR para Ciencia de Datos - Versión en español de conocido libro R fo Data Science de Wickham y Grolemund\nThe Big Book of R - Extensa colección de libros y materiales en línea\n\nRecursos adicionales\n\nIntroduction to bioinformatics for RNA sequence analysis - Tutorial en línea del Laboratorio Grifftih\n\nBibliografia\n\n\nAkalin, A. 2020. Computational Genomics with R.\nAltschul, S.F., Gish, W., Miller, W., Myres, E.W., Lipman, D.J., 1990. Basic local alignment search tool. J. Mol. Biol. 215, 403–410.\nBray, N. L., Pimentel, H., Melsted, P., Pachter, L., 2016. Near-optimal probabilistic RNA-seq quantification. Nat. Biotechnol. 34, 525–527\nBryant, D. M., Johnson, K., DiTommaso, T., Tickle, T., Couger, M. B., Payzin-Dogru, D., Lee, T.J., Leigh, N. D., Kuo, T. H., Davis, F. G., Bateman, J., Bryant, S., Guzikowski, A. R., Tsai, S. L., Coyne, S., Ye, W. W., Freeman, R. M., Jr, Peshkin, L., Tabin, C. J., Regev, A., Haas, B. J., Whited, J. L. 2017. A tissue-mapped Axolotl de novo transcriptome enables identification of limb regeneration factors. Cell Rep. 18, 762–776.\nChen, Y., McCarthy, D., Baldoni, P., et al. 2023 (last revised). edgeR: differential analysis of sequence read count data.\nGrabherr, M. G., Haas, B. J., Yassour, M., Levin, J. Z., Thompson, D. A., Amit, I., Adiconis, X., Fan, L., Raychowdhury, R., Zeng, Q., Chen, Z., Mauceli, E., Hacohen, N., Gnirke, A., Rhind, N., Di-Palma, F., Birren, B.W., Nusbaum, C., Lindblad-Toh, K., Friedman, N., Regev, A. 2011. Full-length transcriptome assembly from RNA-Seq data without a reference genome. Nat. Biotechnol. 29, 644–652.\nKorpelainen, E., Tuimala, J., Somervuo, P., Huss, M., & Wong, G. (2014). RNA-seq data analysis: a practical approach. CRC press.\nNewham, C., Rosenblatt, B. 2009. Learning the bash shell. 3rd edition. O’REILLY.\nSimão, F.A., Waterhouse, R.M., Loannidis, P., Kriventseva, E.V., Zdobnov, E.M. 2015. BUSCO: assessing genome assembly and annotation completeness with single copy orthologs. Bioinformatics. 31, 3210–3212.\nSmith-Unna, R., Boursnell, C., Patro, R., Hibberd, J., Kelly, S. 2016. TransRate: reference free quality assessment of de novo transcriptome assemblies. Genome Res. 26(8), 1134–1144.\nYoung, M. D., Wakefield, M. J., Smyth, G. K., Oshlack, A. 2010. Gene ontology analysis for RNA-seq: accounting for selection bias. Genome Biol. 11, R14."
  },
  {
    "objectID": "2_unix.html#sistema-operativo-gnu-linux",
    "href": "2_unix.html#sistema-operativo-gnu-linux",
    "title": "Introduccion Bash",
    "section": "1.1 Sistema operativo GNU-Linux",
    "text": "1.1 Sistema operativo GNU-Linux\n\nGNU-Linux no es UNIX.\nUNIX No es gratuito y fue desarrollado en los laboratorios Bell de AT&T por Dennis Ritchie, Ken Thompson y Douglas Mclroy.\nGNU es gratuito.\nGNU es de código abierto.\nFue inicialmente desarrollado por Richard Stallman y con el kernel-nucleo de Linus Torvalds, de ahí el nombre.\n\nLinus Torvalds \nAlgunas distribuciones GNU/Linux: \nNosotros tenemos Ubuntu (generalmente) en nuestras computadoras y el escritorio luce en su versión más simple más o menos así:\n\n¿Cómo luce la terminal?, la cuál es más poderosa y es la que estaremos usando (En el modo por defecto, el fondo es negro)",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#que-es-la-shell-bash-",
    "href": "2_unix.html#que-es-la-shell-bash-",
    "title": "Introduccion Bash",
    "section": "1.2. ¿Que es la Shell? –Bash-",
    "text": "1.2. ¿Que es la Shell? –Bash-\n\nLínea de comandos = shell.\nEl nombre «bash» viene del acrónimo «Bourne Again Shell» (llamado así por su inventor Steven Bourne).\nEste fue creado para ser usado en GNU, sustituyendo a su antecesor Bourne shell de UNIX, este último es conocido en el sistema como sh.\nSh, csh, ksh y bash -&gt; Bourne, C, Korn y Bash.\nLa –shell- es un programa que toma comandos ingresados y los procesa para que el sistema operativo sea capaz de realizar las instrucciones.\n\n\n\nbash es amigable.\nLas teclas  nos permiten accesar al historial de comandos.\nLa tecla “tabulador” [TAB] nos permite autocomplementar los nombres de los archivos y/o comandos.\nLas flechas nos permiten desplazarnos a lo largo de la línea de comandos.\n\nLlaves de control más últiles: * Ctrl + c para deterner el comando en curso. * Ctrl + d para cerrar la terminal en turno. * Ctrl + f como alternativa para desplazarnos a la derecha de la línea. * Ctrl + b para desplazarnos a la izquierda de la línea. * Ctrl + r para buscar a través del historial de comandos. * Ctrl + shiff + t para abrir nueva pestaña de terminal.\nEl ícono para abrir la Terminal debe estar en la barra izquierda de sus escritorios. Están buscando algo que se ve así:\n\n¿Qué vemos cuando abrimos la terminal?\n &lt;—- en mi caso\nNormalmente:\n\n\nlaulogan: Indica el usuario conectado a la terminal.\n**@**: significa “en”.\nlaulogan-Inspiron-5558: Indica el nombre de la computadora a la cual estamos conectados (hostName).\n~: Indica la ruta/directorio en la cual nos encontramos, en este caso mi ruta de inicio predeterminada. Alias para user/home/\n$: Indicador para comenzar a escribir nuevas órdenes o comandos. Éste último también indica nuestro estatus dentro del sistema, es decir, si somos usuarios($) o superusuarios(#).\n\nSuper usuario (No teclear)",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#estructura-de-directorios-en-gnulinux",
    "href": "2_unix.html#estructura-de-directorios-en-gnulinux",
    "title": "Introduccion Bash",
    "section": "1.3. Estructura de directorios en GNU/LINUX",
    "text": "1.3. Estructura de directorios en GNU/LINUX\nLo primero que debemos saber es cómo están estructurados los archivos en GNU-Linux.\n\n\nLa base de todo es el directorio raiz, que se representa sencillamente con /. Todos los demás directorios o carpetas tienen que estar ligados a la raiz.\nUna computadora con GNU-Linux puede tener muchos usuarios, los cuales tienen carpetas personales dentro de su carpeta home.\nPor lo general los usuarios pueden hacer cualquier cosa dentro de su home, pero no pueden borrar o modificar cosas que esten afuera.\n\nAhora vamos a darle ordenes a la terminal: Primero, ¿Cómo saber que shell estoy usando? ¡Recuerden no teclear el $!\n$ echo $SHELL o echo $0\n/bin/bash\n¿Cómo seleccionamos una shell en particular?\n$ bash",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#comandos-que-dan-información-del-sistema",
    "href": "2_unix.html#comandos-que-dan-información-del-sistema",
    "title": "Introduccion Bash",
    "section": "2.1 Comandos que dan información del sistema:",
    "text": "2.1 Comandos que dan información del sistema:\narch: Muestra la arquitectura de la máquina.\n$ arch\nx86_64\nuname: Muestra la información del nucleo.\n$ uname\nLinux\ntop: Muestra los procesos que están siendo ejecutados. Para salir teclear q.\n$ top\nTareas: 291 total,   1 ejecutar,  290 hibernar,    0 detener,    0 zombie\n%Cpu(s):  1.2 usuario,  0.5 sist,  0.0 adecuado, 97.8 inact,  0.4 en espera,  0.0 hardw int,  0.0 softw int,  0.0 robar tiempo\nKiB Mem : 16320116 total,  7871832 free,  5008656 used,  3439628 buff/cache\nKiB Swap:  4081660 total,  4081660 free,        0 used. 10551424 avail Mem \n\n  PID USUARIO   PR  NI    VIRT    RES    SHR S  %CPU %MEM     HORA+ ORDEN                                                                      \n 3063 pavel     20   0  796284  57556  35788 S   1.7  0.4   2:37.23 python                                                                     \n 8599 pavel     20   0  796284  57592  35828 S   1.3  0.4   0:20.73 python                                                                     \n 3016 pavel     20   0 3793164 558636 213724 S   1.0  3.4  10:41.32 firefox-bin                                                                \n 4323 pavel     20   0 3528284 641308 132312 S   0.7  3.9   3:17.20 Web Content                                                                \n 9685 pavel     20   0   44540   3816   3088 R   0.7  0.0   0:00.04 top   \nhistory: Con el podemos ver el historial de los comandos ingresados.\n$ history\n1955  ls\n 1956  wc -l Glandula_oviducalPOSvsLO_GO.all_genes_gene_level.txt_down_upgenes.txt_add_annotation.txt Glandula_oviducalPOSvsLO_GO.down_genes_gene_level.txt\n 1957  cd ..\n 1958  ls\n 1959  cd ..\n 1960  ls\n 1961  cd lobulo_optico/\n 1962  ls\n 1963  cd pre-desove/\n 1964  ls\n 1965  ./2.get_gene_names.pl Lobulo_OpticoPREvsGO_GOV.all_genes_gene_level.txt_just_upgenes.txt\nman: Muestra el manual de uso de un comando. Para salir teclear q.\n$ man cat\nCAT(1)                                                         User Commands                                                         CAT(1)\n\nNAME\n       cat - concatenate files and print on the standard output\n\nSYNOPSIS\n       cat [OPTION]... [FILE]...\n\nDESCRIPTION\n       Concatenate FILE(s) to standard output.\n\n       With no FILE, or when FILE is -, read standard input.\n\n       -A, --show-all\n              equivalent to -vET\n\n       -b, --number-nonblank\n              number nonempty output lines, overrides -n\n¿Cómo podemos búscar comandos relacionados con cierta función pero que desconocemos su nombre?. Por ejemplo si quisieramos encontrar el comando que nos da la fecha, ¿Cómo le hacemos?\n$ man -k \"palabra clave\"\n$ man -k \"date\"\n../..\n\ndate (1)             - print or set the system date and time\n\n../..\n$ apropos \"palabra clave\"\n$ apropos date\n../..\ndate (1)             - print or set the system date and time\n../..\nexit: Cierra la terminal en uso.\n$ exit\nAhora, ¿Cómo podemos acceder a todas las opciones que te da un comando?\nuname --help\nModo de empleo: uname [OPCIÓN]...\nMuestra cierta información del sistema. Sin ninguna OPCIÓN, igual que -s.\n\n  -a, --all            muestra toda la información, en el siguiente orden,\n                         excepto que se omite -p y -i si son desconocidos:\n  -s, --kernel-name    muestra el nombre del núcleo\n  -n, --nodename       muestra el nombre de host del nodo de red\n  -r, --kernel-release muestra la versión del núcleo\n  -v, --kernel-version     print the kernel version\n  -m, --machine            print the machine hardware name\n  -p, --processor          print the processor type (non-portable)\n  -i, --hardware-platform  print the hardware platform (non-portable)\n  -o, --operating-system   print the operating system\n      --help     muestra esta ayuda y finaliza\n      --version  informa de la versión y finaliza\n\nayuda en línea sobre GNU coreutils: &lt;http://www.gnu.org/software/coreutils/&gt;\nInforme de errores de traducción en uname a &lt;http://translationproject.org/team/es.html&gt;\nFull documentation at: &lt;http://www.gnu.org/software/coreutils/uname&gt;\nor available locally via: info (coreutils) uname invocation\nEn otros comandos se puede obtener lo mismo usando la bandera: -h, como mencioné anteriormente.",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#comandos-para-manipular-archivos-y-directorios.",
    "href": "2_unix.html#comandos-para-manipular-archivos-y-directorios.",
    "title": "Introduccion Bash",
    "section": "2.2 Comandos para manipular archivos y directorios.",
    "text": "2.2 Comandos para manipular archivos y directorios.\nPara saber en qué lugar-path se encuentran al abrir la terminal:\npwd: de print work directory, te da la ruta actúal donde te encuentras.\n$pwd\n/home/pavel\ncd: de change directory, te permite cambiar de directorios. / accedemos a la raíz del sistema; ~ accedemos al directorio por defecto home/usuario; ../ accedemos al directorio padre, es decir, retrocedemos de nivel. cd - regresamos a donde estabamos.\nPara prácticar vamos a crear dos directorios con el siguiente comando:\nmkdir: Permite crear directorios.\n$ cd #para posicionarnos en /home/user; donde user es su nombre de usuario, en mi caso \"pavel\"\n$ mkdir proyecto #creamos el directorio.\nAhora con el comando cd nos movemos a ese directorio:\n$ cd proyecto\nSi ingresan el comando pwd podrán ver que ahora su posición ha cambiado. Ahora creen en “proyecto” un directorio llamado genoma, y se regresan a su home/usuario\n\nUsando {} como expasión de llaves:\n$ mkdir -p proyecto/{secuencias/rnaseq,blast}\nls: Muestra el contenido de un directorio. -la lista el directorio en formato lista y además muestra todos los archivos ocultos; -h muestra los tamaños del fichero en formato legible; -t acomoda la lista por fecha.\n$ ls -ls\n$ ls -la\n$ ls -lth\n\nPermisos:\n\nchmod: Comando para cambiar permisos.\n$ chmod u+x file\n$ chmod uga+x file\n$ chmod uga-x file\ntouch [filename]: crea archivos vacíos con el nombre especificado.\nvayamonos a cd ~ o solo cd\n$ touch seq.fq\nUsando las llaves podemos generar una seríe de archivos como:\n$ touch seq.fq{1..10}\nseq.fq1  seq.fq10  seq.fq2  seq.fq3  seq.fq4  seq.fq5  seq.fq6  seq.fq7  seq.fq8  seq.fq9\ncp [origen] [destino]: copia archivos de un directorio a otro. También podemos hacer una copia de un archivo y renombrarlo.\n$ cp seq.fq1 copia_seq.fq1\n$ cp seq.* /proyecto/genoma\n$ rm seq.*\n¿Cómo copiar de un directorio a nuestra posición actúal?\n$ cp /proyecto/genoma/seq.* .\n¿Qué pasó?\n-Comodines * (wildcards)\nmv [origen] [destino]: sirve para mover archivos o para renombrar archivos y directorios.\npara renombrar archivos:\n$ mv seq.fq1 seq.fq300\npara mover:\n$ mv seq.fq10 proyecto/genoma/\nrm [file]: Sirve para borrar archivos. -rf borra los archivos de forma recursiva sin preguntar y no vuelven núnca más. rmdir elimina directorios.\n$ rm seq.fq3\n$ rm seq.* #borra todo lo que inicia con seq. seguido de cualquier cosa, usar con cuidado.\n$ mkdir prueba \n$ rm -rf prueba",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#comandos-para-descargar-comprimir-y-descomprimir-archivos.",
    "href": "2_unix.html#comandos-para-descargar-comprimir-y-descomprimir-archivos.",
    "title": "Introduccion Bash",
    "section": "2.3 Comandos para descargar, comprimir y descomprimir archivos.",
    "text": "2.3 Comandos para descargar, comprimir y descomprimir archivos.\nwget: Se usa para descargar archivos del internet via TTP, HTTPS, FTP, o FTPS. wget [OPTIONS]… [ URLS ]\nvamos a descargar el genoma del virus de la influenza:\nwget  ftp://ftp.ncbi.nlm.nih.gov/genomes/INFLUENZA/influenza.faa.gz\nOtro comando similar es curl: Este es más poderoso que wget y acepta más protocolos.\nPara descargar el mismo archivo usariamos el siguiente comando:\ncurl -O ftp://ftp.ncbi.nlm.nih.gov/genomes/INFLUENZA/influenza.faa.gz\ngzip: por GNU zip, esta es una herramienta para comprimir archivos usando la línea de comandos de GNU. Los archivos que son comprimidos usando esta herramienta usualmente contienen la extensión .gz. Para descomprimir usamos gunzip.\nVamos a descomprimir el archivo que recien descargamos.\n$ cd proyecto # nos vamos a la carpeta proyecto\n$ gunzip influenza.faa.gz # descomprir en la carpta proyecto el archivo\nbzip2: Es similar a gzip, pero están construidos bajo diferentes algoritmos.\nbzip2 influenza.faa\nbunzip2 influenza.faa.gz\nLos que quieran saber más sobre el rendiemiento de ambas: https://www.rootusers.com/gzip-vs-bzip2-vs-xz-performance-comparison/\ntar: tar es un programa usado para crear y manipular archivos. tar une varios archivos en uno solo, preservando sus nombres y demás permisos. Resulta muy adecuado cuando se desea almacenar muchos archivos relacionados para que sean transferidos por la red, asi como cuando se hacen respaldos de discos completos y resulta muy práctico para su transporte en diferentes sistemas.\nPara generar un archivo tar de varios usamos el siguiente comando:\n$ touch adn.txt arn.txt\n$ tar -cvf prueba.tar adn.txt arn.txt\n$ tar -xf prueba.tar\n$ tar -cvzf prueba.tar.gz adn.txt arn.txt #empaquetar y comprimir\n$ tar -xzf prueba.tar.gz #desempaquetar y descomprimir\n$ tar -cjvf prueba_2.tar.bz2 adn.txt arn.txt\n$ tar -xjf prueba_2.tar.bz2\n-c: crea un nuevo archivo. -v: verbose, muestra una salida. -z: compresión con gzip. -j: compresión con bzip2. -f: selecciona el archivo que queremos comprimir y siempre debe de ir al final de las opciones. -x: extrae documentos de un archivo tar.",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#comandos-para-visualizar-archivos.",
    "href": "2_unix.html#comandos-para-visualizar-archivos.",
    "title": "Introduccion Bash",
    "section": "2.4 Comandos para visualizar archivos.",
    "text": "2.4 Comandos para visualizar archivos.\nmore: Permite visualizar archivos desde el inicio. Muestra texto en una terminal. Para avanzar presionar ENTER. Para salir de la visualización presionar q. Para visulizar archivos gzip, usamos zmore.\n$ zmore influenza.faa.gz\nless: Permite de igual forma que more visualizar archivos. A diferencia de more se puede retroceder y avanzar con las flechas. Para salir, presionar q.\n$ zless influenza.faa.gz\nAhora vamos a bajarnos el siguiente archivo file.txt en: https://drive.google.com/drive/u/1/folders/14Z7wmv4suhC-DLvDo9tUTNkF8WtVPRSD\nhead: Muestra en la terminal las primeras líneas de un archivo. Para especificar el número de lineas a mostras usar la opción -n.\n$ head -n 20 file.txt\ntail: igual que head pero muestras las líneas al final del documento.\n$ tail -n20 file.txt\nwc: Muestra el número de líneas, caracteres o palabras que contiene un archivo. Opciones -l para líneas, -m para caracteres y -w para palabras.\n$ wc -lmw file.txt\n50  1838 82964 file.txt\nAntes de continuar con los demás comandos vamos a introducir el concepto de entrada y salida estandar.\n\ncat: El comando cat en bash significa “concatenar”. Este comando es usado para mostrar, crear, y agregar archivos.\n$ cat file.txt  #toma la entrada estandar y muestra la salida estandar en pantalla.\nusando el &gt; y &gt;&gt; podemos redirigir la salida estandar, es decir, en lugar que nos mande la salida a la pantalla que la mande a un archivo. Esto para cualquier comando.\n$ cat file.txt &gt; replica_file.txt\nCon este comando, siempre se sobreescribe el archivo. Si quisieramos agregar nueva información al final del archivo usamos el doble mayor &gt;&gt;\n$ cat file.txt &gt;&gt; replica_file.txt\nPara concatenar archivos:\n$ cat file.txt replica_file.txt &gt; conca_ejem.txt\ncut: Extrae información de un archivo. Siempre se debe especificar una opción. -f (campo) más común y el tipo de delimitador -d (por defecto tabulador)\n$ cut -f1 file.txt &gt; first_col.txt\n#gene_id\nTRINITY_DN10676_c0_g1\nTRINITY_DN20389_c0_g1\nTRINITY_DN20515_c0_g1\nsort: Organiza las líneas en un archivo de texto para que se ordenen de forma numérica o alfabéticamente.\n$ sort first_col.txt &gt; first_col_sort.txt\nuniq: Elimina líneas repetidas dentro de un archivo. Sólo funciona con líneas repetidas adyacentes. Primero se deben ordenar las líneas dentro del archivo usando sort.\n$ uniq first_col_sort.txt &gt; first_col_sort_uniq.txt\n¿Cómo podemos hacer todo esto en una sola línea de comando?, aqui es donde entender la entrada y salida estandar se vuelven útiles.\n| Este operador conocido como pipe te permite usar la salida estandar de un comando como entrada estandar de otro.\n$ cut -f1 file.txt | sort | uniq &gt; first_col_sort_uniq_pipe.txt\nNota: Podemos extraer múltiples columnas haciendo cut -f 1,4,8 archivo\ngrep: Este comando nos permite buscar una palabra o un patrón que definamos dentro de un archivo de texto. Por ejemplo, si quisieramos buscar este identificador TRINITY_DN32673_c0_g1 en nuestro archivo de anotación.\n$ grep -i \"TRINITY_DN32673_c0_g1\" file.txt #nos muestra toda la linea de la coincidencia.\n\n$ grep -io \"TRINITY_DN32673_c0_g1\" file.txt #nos muestra solo la concidencia exacta.\n\n$ grep -ic \"^&gt;\" influenza.faa #contar número de secuencias. \nLa opción -i es para que ignore las minusculas y mayusculas, -o para una coincidencia exacta, y la -c cuenta las líneas que tuvieron coincidencia.\nLa variante de grep que te permite buscar patrones es egrep. En este curso no entraremos a detalle. A los que les interese primero deben buscar sobre expresiones regulares. Les recomiendo este libro —&gt; https://doc.lagout.org/operating%20system%20/linux/grep%20-%20Pocket%20Reference.pdf\nsed: Este comando nos permite buscar con texto y/o patrones y reemplazar las coincidencias.\nsed ‘s/buscar/reemplazar/g’ # La g aqui es por global y significa que haga el cambio en todas las coincidencias, no solo en la primera. Si quieren modificar en el mismo archivo usar la opción -i.\n$ sed 's/TRINITY/trinity/g' file.txt &gt; file_sed.txt",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#enlace-simbólico.",
    "href": "2_unix.html#enlace-simbólico.",
    "title": "Introduccion Bash",
    "section": "2.5 Enlace simbólico.",
    "text": "2.5 Enlace simbólico.\nUn enlace simbólico es un archivo que apunta a otro archivo (o a un directorio), estos son como los “accesos directos” en Windows. Su finalidad es la de no duplicar archivos para no usar más memoria, en especial aquellos que son de gran tamaño.\nln -s [Origen] [Destino] : Link (enlace) simbólico indica un acceso directo a una carpeta o archivo que se encuentra en un lugar distinto dentro de la estructura de directorios. Si el archivo ligado es renombrado, movido o borrado se rompe el acceso.\n$ ln -s proyecto/genoma/ . #en este caso hicimos un link al directorio genoma.\n$ rm o unlink genoma #para eliminar el enlace simbolico.",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#comando-para-conexión-remota",
    "href": "2_unix.html#comando-para-conexión-remota",
    "title": "Introduccion Bash",
    "section": "2.6 Comando para conexión remota",
    "text": "2.6 Comando para conexión remota\nssh: Es un programa para iniciar sesión y ejecutar comandos en una maquina remota. Proporciona comunicaciones cifradas seguras a través de una red insegura.\n$ ssh [user@]hostname\n\n2.6.1 Conexión a la red local de cicese\nPara conectarse a la red de CICESE a través de VPN deben seguir las instrucciones siguientes:\nContar con:\n\nUsuario de cuenta de correo CICESE\nContraseña original\n\nPaso 1: Instalar vpn\n$ sudo apt-get install vpnc\nPaso 2: Acceder a VPN de CICESE\n$ sudo vpnc\nPaso 3: Colocar la información requerida.\nIPSeq gateway adress: 158.97.255.193\nIPSeq ID: VPNCICESE\nIPSeq secret: c1c3s3VPN\nUsername: &lt;usuario&gt;\nPassword: &lt;contraseña_original&gt;\nTip: para no estár ingresando estos datos cada vez que queremos conectarnos a la red del cicese.\n\nIr a /etc/vpnc.conf\nAgregar la información anterior.\nListo\n\nAhora para conectarse solo escribirán:\n$ sudo vpnc #les pedirá su contraseña de sesión por usar sudo\nSi la conexión fue exitosa, verán en su pantalla algo como:\nConnect Banner:\n| Conexion VPN establecida - Bienvenido a la Red CICESE\n| \n| Por favor lea las politicas de uso del servicio de VPN disponibles en:\n| \n| http://telematica.cicese.mx\n| \n| Haga click en \"Continuar\" (o en \"OK\") para empezar a hacer uso del servicio de VPN.\n| \n| Haga click en \"Desconectar\" para cancelar esta sesion.\n| \n| Mensaje escrito sin acentos.\n| \n\nVPNC started in background (pid: 1362)...\nPara desconectarse:\n$ sudo vpnc-disconnect # recuerden pueden usar TAB para autocoplementar\n$ ps -aux | grep \"vpnc\" # en algunos casos\n$ kill IDjob # kill nos permite matar un proceso.\n\n\n2.6.2 Acceso a la supercomputadora/Cluster OMICA\nCada estudiante deberá acceder al cluster OMICA con una cuenta del curso.\n\nDirectorio base de trabajo: /LUSTRE/bioinformatica_data/curso2022\nRecordando que deben trabajar en la zona de lustre y no en sus directorios personales para lo cual deben utilizar: cd curso2022 Esta instrucción posicionará a cada estudiante en la trayectoria de su respectivo subdirectorio: /LUSTRE/bioinformatica_data/curso2022/accounts/cursoNN\nSubstituir el doble hash (##) por el número de cuenta asignado (ver tabla arriba).\n$ ssh curso##@omica\nTip: Para hacer el acceso menos laborioso seguir los siguientes pasos:\n\nIr a /home/pavel/.ssh #sustituir pavel por su nombre de usuario.\nAbrir el archivo oculto .ssh.\npegar:\n\nHost cicese HostName omica User pgalindo #poner el suyo.\nAhora para conectarse solo bastará:\n$ssh cicese #Les pedirá su contraseña de usuario.\n\n2.6.2.1 Copiar archivos de manera remota, servidor(omica)-pc. Bidireccional.\nSi quisieramos enviar un archivo a nuestro home en omica:\nekggibujd defualt $ scp file_sed.txt curso01@omica:/home/curso01/ekggibujd\nAhora, copiar de omica a nuestro pc:\n$ rm file_sed.txt #primero borramos el archivo file_sed.txt en nuestro ordenador\n$ scp curso01@omica:/home/curso01/file_sed.txt .",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#resumen-de-comandos.",
    "href": "2_unix.html#resumen-de-comandos.",
    "title": "Introduccion Bash",
    "section": "2.7 Resumen de comandos.",
    "text": "2.7 Resumen de comandos.",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#hacer-nuestros-propios-comandos",
    "href": "2_unix.html#hacer-nuestros-propios-comandos",
    "title": "Introduccion Bash",
    "section": "2.8 Hacer nuestros propios comandos",
    "text": "2.8 Hacer nuestros propios comandos\nEsta herramienta resulta muy útil para acortar la escritura de instrucciones largas, por ejemplo:\n$ alias l='wc -l' # contar líneas de archivo\n$ alias pulpo='cd /media/pavel/Pavel/librerias_ml/proyecto_omaya_embriones'\n$ alias sec='cd /home/pavel/proyecto/secuencias/; ls'\nPara remover el alias teclear unalias. Para hacerlo permanente ir a home/user, abrir el archivo .bashrc y agregar la instrucción en la sección de alias. Al abrir una nueva terminal, este alias será permanente.",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#editor-de-texto-en-la-terminal",
    "href": "2_unix.html#editor-de-texto-en-la-terminal",
    "title": "Introduccion Bash",
    "section": "2.9 Editor de texto en la terminal",
    "text": "2.9 Editor de texto en la terminal\nnano: Es un editor de texto que es fácil de usar. Incluye todas las funcionalidades básicas que podrías esperar de un editor de textos regular.\n$ nano prueba.txt\nUna vez abierto pueden ingresar el texto que deseen. Para guardar Ctrl + O y pasa salir Ctrl + x.\n\nAcá les dejo otros editores más amigables: Sublime Text:\nLink: https://www.sublimetext.com/ \nVisual Studio Code: Link: https://code.visualstudio.com/",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#gnulinux",
    "href": "2_unix.html#gnulinux",
    "title": "Introduccion Bash",
    "section": "4.1 GNU/Linux",
    "text": "4.1 GNU/Linux\nDependiento de la distribución de GNU-Linux que estemos usando vamos a emplear un comando para poder descargar, instalar y borrar software con sus respectivas dependencias. Generalmente el comando más común es: apt-get\n$ sudo apt-get update #este codigo actualiza los paquetes ya intalados. Se necesitan privilegios de super usuario.\nsudo apt-get install [Nombre del paquete] #Para instalar paquete\nsudo apt remove [Nombre del paquete] # borrar paquete o paquetes.",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#macos",
    "href": "2_unix.html#macos",
    "title": "Introduccion Bash",
    "section": "4.2 MacOS",
    "text": "4.2 MacOS\nHomebrew: Homebrew instala todo aquello que necesitas pero que no viene por defecto instalado (más detalle en: https://brew.sh/index_es) \nUna vez instalado pueden por ejemplo correr el siguiente comando para instalar wget:\n$ brew install wget",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#ambientes-virtuales",
    "href": "2_unix.html#ambientes-virtuales",
    "title": "Introduccion Bash",
    "section": "4.3 Ambientes virtuales",
    "text": "4.3 Ambientes virtuales\n\n4.3.1 Conda:\n\nConda es un manejador de paquetes, dependencias y ambientes para cualquier lenguaje, Python, R, Ruby, Lua, etc. Conda puede correr en windows, macOS y GNU-Linux.\n\nVisiten el siguiente link para entrar más a detalle sobre los comandos para gestionar paquetes y ambientes –&gt; https://docs.conda.io/projects/conda/en/latest/index.html",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#sintaxis",
    "href": "2_unix.html#sintaxis",
    "title": "Introduccion Bash",
    "section": "5.1 Sintaxis",
    "text": "5.1 Sintaxis\n\nif/else:\nif [[ CONDICION ]]; then\n    echo \"la condición se cumplió\"\nelse\n    echo \"la condición no se cumplió\"\nfi\nMás de una condición:\nif [[ CONDICION ]]; then\n    echo \"la condición se cumplió\"\nelif [[ CONDICION 2 ]]; then\n    echo \"la condición 1 no se cumplió pero la 2 si\"\nelse\n    echo \"ninguna condición se cumplió\"\nfi\n\n\nfor:\nfor var in list\ndo\n  command1\ndone\nOtra variante:\nfor((i=1;i&lt;=10;i+=2)); do \necho \"Welcome $i times\"; \ndone\n\n\nwhile:\nwhile [condition]\ndo\n   command-1\n   command-2\n     ...\n     ...\n   command-n\ndone",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html#finalmente",
    "href": "2_unix.html#finalmente",
    "title": "Introduccion Bash",
    "section": "Finalmente…",
    "text": "Finalmente…",
    "crumbs": [
      "Inicio",
      "Introduccion Bash"
    ]
  },
  {
    "objectID": "2_unix.html",
    "href": "2_unix.html",
    "title": "Introduccion Bash",
    "section": "",
    "text": "code"
  },
  {
    "objectID": "1_Rbasico.html",
    "href": "1_Rbasico.html",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "",
    "text": "R es un lenguaje de programación y un entorno de software libre dedicado principalmente al análisis estadístico y la visualización de datos. Desarrollado inicialmente por los laboratorios de AT&T a pártir de otro lenguaje de programación.\nEntre las caracteristicas que han hecho de R un lenguaje muy popular entre la comunidad científica y academica (ademas de que es gratuito 😉 ) es su capacidad para manejar y analizar grandes conjuntos de datos, junto con una vasta colección de paquetes desarrollados por la comunidad, lo hace altamente versátil y poderoso.\nAdemás, R se destaca por su capacidad para crear gráficos de alta calidad y visualizaciones interactivas, lo que facilita la interpretación y comunicación de resultados complejos. La facilidad de integración con otros lenguajes y sistemas, así como su fuerte enfoque en la reproducibilidad de la investigación, han cimentado su lugar como una herramienta indispensable para científicos, estadísticos y analistas de datos en todo el mundo.\n¿Mencioné que R es gratuito?",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Rbasico.html#trabajando-con-vectores",
    "href": "1_Rbasico.html#trabajando-con-vectores",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Trabajando con vectores",
    "text": "Trabajando con vectores\nEjercicio:\nSupón que tienes un cultivo de moluscos y tienes que revisarlo todos los días y contar los organismos muertos. Después de una semana tienes el siguiente resultado:\n\nlunes: 4\nmartes: 6\nmiercoles: 0\njueves: 10\nviernes: 12\nsabado: 8\ndomingo: 4\n\n1: crea un vector con los valores diarios 2: nombre cada valor con el dia de la semana usando la funcion names()\n\nmortalidad &lt;- c(4,6,0,10,12,8,4)\nmortalidad\n\n[1]  4  6  0 10 12  8  4\n\n#nombrar la mortalidad con la funcion names\nnames(mortalidad) &lt;-  c(\"Lun\", \"Mar\", \"Mie\", \"Jue\", \"Vie\", \"Sab\", \"Dom\")\n\nmortalidad\n\nLun Mar Mie Jue Vie Sab Dom \n  4   6   0  10  12   8   4 \n\n\nOperaciones basicas con vectores\n\n\n\nFunción\nsignificado\n\n\n\n\nmin()\nMinimo\n\n\nmax()\nMáximo\n\n\nlength()\nlongitud\n\n\nrange()\nintervalo de valores\n\n\nsort()\nOrdena de menor a mayor\n\n\nunique()\nValores unicos\n\n\nmean()\nPromedio\n\n\nsum()\nsuma\n\n\nwhich()\nproporciona los indices TRUE\n\n\n\n\n\n\n\n\n\nEjercicio\n\n\n\n\n¿Cual fue el valor mínimo ?\n¿Cuantos organismos murieron esa semana?\n\n\n\n\nIndice posicional\nUsar índices para obtener subconjuntos es el procedimiento más universal en R, pues funciona para todas las estructuras de datos.\nUn índice en R representa una posición. Cuando usamos índices le pedimos a R que extraiga de una estructura los datos que se encuentran en una o varias posiciones específicas dentro de ella.\nPara obtener subconjuntos con índices escribimos corchetes [ ] después del nombre de un objeto. Dentro de los corchetes escribimos el o los números que corresponden a la posición que nos interesa extraer del objeto.\nPor ejemplo, para extraer el primer valor de mortalidad\n\nmortalidad[1]\n\nLun \n  4 \n\n\nTambién podemos extraer mas valores usando la función c() dentro de los corchetes. Por ejemplo, para extraer el primer, tercer y cuarto valor de mortalidad\n\nmortalidad[c(1,3,4)]\n\nLun Mie Jue \n  4   0  10 \n\n\no usar un intervalo de valores con el operador :\n\nmortalidad[1:4]\n\nLun Mar Mie Jue \n  4   6   0  10 \n\n\nPodemos usar números negativos para mostrar todos los valores excepto el segundo\n\nmortalidad[-2]\n\nLun Mie Jue Vie Sab Dom \n  4   0  10  12   8   4 \n\n\no si por el contrario queremos eliminar varios elementos usamosc(-)\n\nmortalidad[-c(1,2:4)]\n\nVie Sab Dom \n 12   8   4 \n\n\n\n\nIndice lógico\nOtra forma de extraer datos de un vector es usando expresiones lógicas como indice. Por ejemplo, para extraer los días con una mortalidad mayor a 5\n\n#Mostrar solo los dias donde la mortalidad fue &gt; 5\nmortalidad[mortalidad &gt; 5]\n\nMar Jue Vie Sab \n  6  10  12   8 \n\n\nDe esta forma R extraerá solamente los valores TRUE\nDe la misma manera podemos utilizar otros operadores para incrementar la complejidad de la expresión. Por ejemplo, podemos pedirle los valores que sean mayor o igual &gt;= a una cierta cantidad, que sea exactamente igual == o que sea diferente != a una cantidad.\n\nmortalidad[mortalidad == 4] #valores iguales a 4\n\nLun Dom \n  4   4 \n\n\n\nmortalidad[mortalidad != 4] #valores diferentes a 4\n\nMar Mie Jue Vie Sab \n  6   0  10  12   8 \n\n\n\n\n\n\n\n\n¡Ojo!\n\n\n\nEn R, =y == tienen usos distintos y no son intercambiables.\n= se utiliza para asignar un valor a una variable, mientras que == se utiliza para comparar dos valores y determinar si son iguales TRUE o no FALSE\n\n\n\n\n\n\n\n\nWarning\n\n\n\nEjercicio\nIdentificar:\n\n¿En que día se observó la menor mortalidad?\n¿Que días tuvieron una mortalidad igual a 12?\n¿Que días tuvieron una mortalidad menor al promedio?\n\n\n\n\n\nReemplazar elementos\nPara reemplazar un elemento en un vector podemos utiliza los indices, con [ ] en combinación con el operador de asignación &lt;-. Por ejemplo, si quieres cambiar el valor del día lunes (primer elemento) de 4 a 8\n\nmortalidad[1] &lt;- 8\nmortalidad\n\nLun Mar Mie Jue Vie Sab Dom \n  8   6   0  10  12   8   4 \n\n\n\n\n\n\n\n\nvectores con nombre\n\n\n\nCuando tu vector tiene nombres asignados a cada elemento (names) tal como lo hicimos con nuestro vector de mortalidad, puedes extraer o seleccionar un elemento usando su nombre. Por ejemplo, si queremos regresar el valor del lunes a 4\n\nmortalidad[\"Lun\"] &lt;- 4",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Rbasico.html#introducción",
    "href": "1_Rbasico.html#introducción",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "",
    "text": "R es un lenguaje de programación y un entorno de software libre dedicado principalmente al análisis estadístico y la visualización de datos. Desarrollado inicialmente por los laboratorios de AT&T a pártir de otro lenguaje de programación.\nEntre las caracteristicas que han hecho de R un lenguaje muy popular entre la comunidad científica y academica (ademas de que es gratuito 😉 ) es su capacidad para manejar y analizar grandes conjuntos de datos, junto con una vasta colección de paquetes desarrollados por la comunidad, lo hace altamente versátil y poderoso.\nAdemás, R se destaca por su capacidad para crear gráficos de alta calidad y visualizaciones interactivas, lo que facilita la interpretación y comunicación de resultados complejos. La facilidad de integración con otros lenguajes y sistemas, así como su fuerte enfoque en la reproducibilidad de la investigación, han cimentado su lugar como una herramienta indispensable para científicos, estadísticos y analistas de datos en todo el mundo.\n¿Mencioné que R es gratuito?",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Rbasico.html#generalidades",
    "href": "1_Rbasico.html#generalidades",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Generalidades",
    "text": "Generalidades\nEn este primer capítulo vamos a revisar algunas funcionalidades básicas de R tales como crear objetos y vectores asi como revisar los diferentes tipos de estructuras de datos.\nAntes de empezar, es importante mencionar algunas aspectos:\n\nR es sensible a las mayúsculas y minúsculas, de manera que A es diferente que a de la misma forma que la función anova() es diferente a la función Anova()\nEl símbolo # sirve para insertar un comentario en la línea de comando, de manera que todo lo que siga después de # no se ejecutara. Es importante incluir comentarios como parte de las buenas practicas en el uso de R ya que le facilitará el trabajo a tus colaboradores y revisores saber que estas haciendo en casa paso y te salvará la vida cuando intentes correr tu script cinco años después de haberlo escrito\nEn la consola usualmente veremos el símbolo &gt; lo que la indica que la consola esta lista para recibir nuevas instrucciones. Si por el contrario vemos el símbolo + entonces nos esta indicando que no hemos terminado de completar correctamente una línea de código.\nSi despúes de ejecutar un comando la consola nos arroja un mensaje de advertencia WARNING significa que el comando se ejecutó pero hay algo inesperado que debe revisarse. Por el contrario si nos arroja un mensaje de error ERROR entonces hay algo mal en la línea de codigo y por lo tanto no se pudo ejecutar.",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Rbasico.html#uso-de-la-línea-de-comando-como-calculadora",
    "href": "1_Rbasico.html#uso-de-la-línea-de-comando-como-calculadora",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Uso de la línea de comando como calculadora",
    "text": "Uso de la línea de comando como calculadora\nPodemos utilizar R para realizar operaciones básicas:\n\n1 + 2 #suma\n\n[1] 3\n\n4 - 3 #resta\n\n[1] 1\n\n5 * 5 #multiplicación\n\n[1] 25\n\n4 / 2 #división\n\n[1] 2\n\n4 ^ 2 #Exponente\n\n[1] 16\n\n4 ** 2 #Exponente\n\n[1] 16\n\n\n\n\n\n\n\n\n!! ¿por qué hay un [1] en cada resultado?\n\n\n\nEl resultado es un vector, aunque solo consista en un elemento. Por lo tanto, R indica que este el primer [1] elemento de un vector\n\n\nOperadores en R:\n\n\n\nOperador\nsignificado\n\n\n\n\n*\nMultiplicación\n\n\n-\nResta\n\n\n+\nSuma\n\n\n^\nElevar a potencia\n\n\n/\nDivisión\n\n\n&lt;\nMenor que\n\n\n&gt;\nMayor que\n\n\n&lt;=\nMenor o igual que\n\n\n&gt;=\nMayor o igual que\n\n\n==\nExactamente igual\n\n\n!=\nDistinto",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Rbasico.html#uso-de-objetos",
    "href": "1_Rbasico.html#uso-de-objetos",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Uso de objetos",
    "text": "Uso de objetos\nPara crear un nuevo objeto se puede usar “=” o “&lt;-”. Este nuevo objeto, se almacenará en la memoria y se puede usar para otras operaciones.\n\nx &lt;- 2 #asignar a la variable x el valor de 2\nx\n\ny = 3 #asignar a la variable y el valor de 3\ny\n\n#resultado de la suma x + y\nx + y\n\nz &lt;- x + y #asiganr el resultado de x + y  a la variable z\nz\n\n\n\n\n\n\n\nEjercicio\n\n\n\n\nCambia el valor de la variable x a 5. ¿Que pasa con z?\nQue tengo que hacer para actualizar el objeto z\n\n\n\nLas variables no solo puede contener números, sino caracteres, listas o incluso graficas\n\ncaracter &lt;- \"siete\"\ncaracter\n\n[1] \"siete\"\n\n\n\n\n\n\n\n\nConsejos para nombrar variables\n\n\n\nEs posible asignar casi cualquier nombre a un objeto aunque existen algunas reglas y recomendaciones que hay que considerar:\n\nEvita iniciar con un número (2x incorrecto ero x2 es valido).\nEvita usar nombres de funciones (ifelse, for, c, etc.).\nUsa guiones bajos para separar palabras. (snake_case).\nEvita nombres de una sola letra.\nProcura usar nombres claros y descriptivos. El nombre debe ser lo suficientemente claro para que alguien más (o tú mismo en el futuro) pueda entender su propósito sin necesidad de comentarios adicionales.\n\n\n\n\n\n\n\n\n\nEjercicio:\n\n\n\n¿Cuales de estas formas de definir una variables es incorrecta?\n\nmi.variable &lt;-\nmi_variable &lt;-\nmi variable &lt;-\nmi-variable &lt;-",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Rbasico.html#tipos-y-estructura-de-datos-classes",
    "href": "1_Rbasico.html#tipos-y-estructura-de-datos-classes",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Tipos y estructura de datos (Classes)",
    "text": "Tipos y estructura de datos (Classes)\nR tiene los siguientes tipos de datos basicos:\n\nlogical: valores lógicos, pueden ser TRUE o FALSE\nnumeric: números reales (1.0,2,3.1416, 3E-10)\ncharacter:caracteres (letras y/o números). Delimitados por “” (“uno”, “Miguel”, “FALSO”)\ninterger:valores enteros (1,2,3)\nNA: dato no disponible\nNaN:no es un número (not a number)\n\nPor otro lado, las estructuras de datos pueden ser de tipo vector, data.frame, matriz, arreglo o lista:\n\nfuente: http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png\nEs importante resaltar que solamente los data.frame pueden contener distintos tipos de datos (números, caracteres, etc) mientras que el resto solo puede contener un tipo de dato (solo carácteres, solo números, etc).\n\nSi no sabes que tipo de dato contiene una variable, se puede sar la función class()\n\nclass(x)      \n\n[1] \"numeric\"\n\nclass(caracter)     \n\n[1] \"character\"\n\n\n\n\n\n\n\n\n¿Funciones? 🤔\n\n\n\nR utiliza funciones para realizar operaciones, por ejemplo class(). Para utilizar una función deben especificarse determiandos argumentos, los cuales se escriben dentro del parentesis.\nUna ventaja de utilizar Rstudio, es que al abrir una función, automaticamente te desplegará las opciones de argumentos. Por ejemplo, escribe en la terminal round(). Tras completarse la función, te desplegara la información round(x, digits = 0) donde x es el objecto (número o vector) y digits es el número de decimales.",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Rbasico.html#indices",
    "href": "1_Rbasico.html#indices",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Indices",
    "text": "Indices\nUsar índices para obtener subconjuntos es el procedimiento más universal en R, pues funciona para todas las estructuras de datos.\nUn índice en R representa una posición. Cuando usamos índices le pedimos a R que extraiga de una estructura los datos que se encuentran en una o varias posiciones específicas dentro de ella.\nPara obtener subconjuntos con índices escribimos corchetes [] después del nombre de un objeto. Dentro de los corchetes escribimos el o los números que corresponden a la posición que nos interesa extraer del objeto.\n\nmortalidad[1]\n\nLun \n  4 \n\n\nMostrar todos los valores excepto el segundo\n\nmortalidad[-2]\n\nLun Mie Jue Vie Sab Dom \n  4   0  10  12   8   4 \n\n\nSe puede obtener multiples series de elementos al mismo tiempo usando c()\n\nmortalidad[c(1,2:4)]\n\nLun Mar Mie Jue \n  4   6   0  10 \n\n\no si por el contrario queremos eliminar estos elementos se usa c(-)\n\nmortalidad[-c(1,2:4)]\n\nVie Sab Dom \n 12   8   4 \n\n\nObtener los dias en donde la mortalidad fue mayor a 5\n\nmortalidad &gt; 5\n\n  Lun   Mar   Mie   Jue   Vie   Sab   Dom \nFALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE \n\n#Mostrar solo los dias donde la mortalidad fue &gt; 5\nmortalidad[mortalidad &gt; 5]\n\nMar Jue Vie Sab \n  6  10  12   8 \n\n\nEjercicio\nIdentificar:\n\n¿En que dia se observó la menor mortalidad?\n¿Que dias tuvieron una mortalidad igual a 12?\n¿Que dias tuvieron una mortalidad menor al promedio?"
  },
  {
    "objectID": "1_Rbasico.html#acceder-a-elementos-de-un-data.frame",
    "href": "1_Rbasico.html#acceder-a-elementos-de-un-data.frame",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Acceder a elementos de un data.frame",
    "text": "Acceder a elementos de un data.frame\nPara acceder a los elementos de un data.frame podemos utilizar el simbolo $ o utilizando indices [F, C] donde el primer elemento antes de la coma, son las filas y el segundo elemento las columnas.\nPor ejemplo, para acceder al vector de los nombres\n\nmi_df$Nombre\n\n[1] \"Alex\"     \"Lilly\"    \"Mark\"     \"Oliver\"   \"Martha\"   \"Lucas\"    \"Caroline\"\n\n\no usando los indices\n\nmi_df[ , 1]\n\n[1] \"Alex\"     \"Lilly\"    \"Mark\"     \"Oliver\"   \"Martha\"   \"Lucas\"    \"Caroline\"\n\n\n\n\n\n\n\n\nTip\n\n\n\nPara acceder a todas las filas de una determinada columna, dejamos ese espacio en blanco antes de la coma. Por el contrario si queremos seleccionar la primera fila de todas las columnas utilizariamos:\n\nmi_df[1, ]\n\n  Nombre Edad Altura Peso Sexo\n1   Alex   25    177   57    M\n\n\n\n\no podemos usar el nombre de la columna dentro del indice\n\nmi_df[, \"Nombre\"]\n\n[1] \"Alex\"     \"Lilly\"    \"Mark\"     \"Oliver\"   \"Martha\"   \"Lucas\"    \"Caroline\"",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Rbasico.html#creación-de-matrices",
    "href": "1_Rbasico.html#creación-de-matrices",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Creación de matrices",
    "text": "Creación de matrices\nPara crear una matriz se usa la función matrix(), la cual usa los argumentos nrow y ncol. Con ellos se especifica el número de renglones y columnas que tendrá nuestra matriz.\n\n#matriz sin especificar renglones ni columnas\nmatrix(1:12)\n\n      [,1]\n [1,]    1\n [2,]    2\n [3,]    3\n [4,]    4\n [5,]    5\n [6,]    6\n [7,]    7\n [8,]    8\n [9,]    9\n[10,]   10\n[11,]   11\n[12,]   12\n\n\nAhora usamos la misma serie de números pero definiendo 3 filas y 4 columnas\n\nmatrix(1:12, nrow = 3, ncol = 4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n\nAhora usando la misma serie de números pero con 4 filas y 3 columnas\n\nmatrix(1:12, nrow = 4, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\n\n\n¿Que pasa si definimos un menor número de filas y columnas que el número de elementos?\n¿Que pasa si usamos un número mayor de filas y columnas que el número total de elementos"
  },
  {
    "objectID": "1_Rbasico.html#arreglos",
    "href": "1_Rbasico.html#arreglos",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Arreglos",
    "text": "Arreglos\nson similares a las matrices pero pueden contener 2 o mas dimensiones\n\narreglo &lt;- array(1:24, dim = c(2,3,4))\narreglo\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]   13   15   17\n[2,]   14   16   18\n\n, , 4\n\n     [,1] [,2] [,3]\n[1,]   19   21   23\n[2,]   20   22   24",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Rbasico.html#vectores",
    "href": "1_Rbasico.html#vectores",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Vectores",
    "text": "Vectores\nUn vector es la estructura de datos más sencilla en R. Un vector es una colección de uno o más datos del mismo tipo.\nPara crear un vector utilizamos el comando c(), de combinar\n\nnumeros &lt;- c(1, 2, 3)\n\nnumeros\n\n[1] 1 2 3\n\n\nTambién podemos crear un nuevo vector a partir de otros objetos en el ambiente, como por ejemplo, los objetos x, y y z que ya tenemos.\n\nvariables &lt;- c(x, y, z)\nvariables\n\n[1] 2 3 5\n\n\nLos vectores tambien puende contener elementos de otros tipos como caracteres, los cuales tienen que ir dentro de comillas \" \".\n\nnombres &lt;- c(\"Juan\", \"Pepe\", \"Sofia\")\n\n\n\n\n\n\n\nWarning\n\n\n\n¿Que pasa si intentamos unir el vector de caracteres (nombres) con numeros (variables)\n\nnombre_variable &lt;- c(nombres, variables)\nnombre_variable\n\n[1] \"Juan\"  \"Pepe\"  \"Sofia\" \"2\"     \"3\"     \"5\"    \n\n\nComo las cadenas de texto son el tipo de dato más flexible, siempre que creamos un vector que incluye un dato de este tipo, el resultado será un vector de texto.\n\n\nPodemos crear vectores de secuencias numéricas usando :. De un lado de los dos puntos escribimos el número de inicio de la secuencia y del otro el final.\nPor ejemplo, creamos una secuencia del 1 al 10\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\nVectorización de operaciones\nLas operaciones aritméticas y relacionales pueden vectorizarse. Si las aplicamos a un vector, la operación se realizará para cada uno de los elementos que contiene.\nPor ejemplo, podemos sumar 2 a cada uno de los elementos del vector numeros\n\nnumeros + 2\n\n[1] 3 4 5\n\n\nTambién podemos realizar operaciones relacionales (VERDADERO, FALSO) con nuestro vector. Por ejemplo, evaluar cual de nuestro elementos es mayor a 4\n\nnumeros &gt; 2\n\n[1] FALSE FALSE  TRUE",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Rbasico.html#indice-posicional",
    "href": "1_Rbasico.html#indice-posicional",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Indice posicional",
    "text": "Indice posicional\nUsar índices para obtener subconjuntos es el procedimiento más universal en R, pues funciona para todas las estructuras de datos.\nUn índice en R representa una posición. Cuando usamos índices le pedimos a R que extraiga de una estructura los datos que se encuentran en una o varias posiciones específicas dentro de ella.\nPara obtener subconjuntos con índices escribimos corchetes [ ] después del nombre de un objeto. Dentro de los corchetes escribimos el o los números que corresponden a la posición que nos interesa extraer del objeto.\nPor ejemplo, para extraer el primer valor de mortalidad\n\nmortalidad[1]\n\nLun \n  4 \n\n\nTambién podemos extraer mas valores usando la función c() dentro de los corchetes. Por ejemplo, para extraer el primer, tercer y cuarto valor de mortalidad\n\nmortalidad[c(1,3,4)]\n\nLun Mie Jue \n  4   0  10 \n\n\no usar un intervalo de valores con el operador :\n\nmortalidad[1:4]\n\nLun Mar Mie Jue \n  4   6   0  10 \n\n\nPodemos usar números negativos para mostrar todos los valores excepto el segundo\n\nmortalidad[-2]\n\nLun Mie Jue Vie Sab Dom \n  4   0  10  12   8   4 \n\n\no si por el contrario queremos eliminar varios elementos usamosc(-)\n\nmortalidad[-c(1,2:4)]\n\nVie Sab Dom \n 12   8   4"
  },
  {
    "objectID": "1_Rbasico.html#indice-lógico",
    "href": "1_Rbasico.html#indice-lógico",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Indice lógico",
    "text": "Indice lógico\nOtra forma de extraer datos de un vector es usando expresiones lógicas como indice. Por ejemplo, para extraer los días con una mortalidad mayor a 5\n\n#Mostrar solo los dias donde la mortalidad fue &gt; 5\nmortalidad[mortalidad &gt; 5]\n\nMar Jue Vie Sab \n  6  10  12   8 \n\n\nDe esta forma R extraerá solamente los valores TRUE\nDe la misma manera podemos utilizar otros operadores para incrementar la complejidad de la expresión. Por ejemplo, podemos pedirle los valores que sean mayor o igual &gt;= a una cierta cantidad, que sea exactamente igual == o que sea diferente != a una cantidad.\n\nmortalidad[mortalidad == 4] #valores iguales a 4\n\nLun Dom \n  4   4 \n\n\n\nmortalidad[mortalidad != 4] #valores diferentes a 4\n\nMar Mie Jue Vie Sab \n  6   0  10  12   8 \n\n\n\n\n\n\n\n\n¡Ojo!\n\n\n\nEn R, =y == tienen usos distintos y no son intercambiables.\n= se utiliza para asignar un valor a una variable, mientras que == se utiliza para comparar dos valores y determinar si son iguales TRUE o no FALSE\n\n\n\n\n\n\n\n\nWarning\n\n\n\nEjercicio\nIdentificar:\n\n¿En que día se observó la menor mortalidad?\n¿Que días tuvieron una mortalidad igual a 12?\n¿Que días tuvieron una mortalidad menor al promedio?"
  },
  {
    "objectID": "1_Rbasico.html#reemplazar-elementos",
    "href": "1_Rbasico.html#reemplazar-elementos",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Reemplazar elementos",
    "text": "Reemplazar elementos\nPara reemplazar un elemento en un vector podemos utiliza los indices, con [ ] en combinación con el operador de asignación &lt;-. Por ejemplo, si quieres cambiar el valor del día lunes (primer elemento) de 4 a 8\n\nmortalidad[1] &lt;- 8\nmortalidad\n\nLun Mar Mie Jue Vie Sab Dom \n  8   6   0  10  12   8   4 \n\n\n\n\n\n\n\n\nvectores con nombre\n\n\n\nCuando tu vector tiene nombres asignados a cada elemento (names) tal como lo hicimos con nuestro vector de mortalidad, puedes extraer o seleccionar un elemento usando su nombre. Por ejemplo, si queremos regresar el valor del lunes a 4\n\nmortalidad[\"Lun\"] &lt;- 4"
  },
  {
    "objectID": "1_Rbasico.html#factores",
    "href": "1_Rbasico.html#factores",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Factores",
    "text": "Factores\nLos factores son un tipo especial de vector utilizado para almacenar datos categoricos. Cada categoría se refiere a un nivel del factor de manera que a cada nivel se le asgina un valor entero (integer).\n\ncategorias &lt;- c(\"alto\", \"medio\", \"bajo\", \"alto\", \"bajo\", \"alto\", \"bajo\")\n\ncategorias &lt;- factor(categorias)\n\ncategorias\n\n[1] alto  medio bajo  alto  bajo  alto  bajo \nLevels: alto bajo medio",
    "crumbs": [
      "Inicio",
      "R y Rstudio: Comandos Basicos"
    ]
  },
  {
    "objectID": "1_Proyectos.html",
    "href": "1_Proyectos.html",
    "title": "Importar y exportar datos",
    "section": "",
    "text": "El directorio de trabajo es la ubicación por defecto donde R estará buscando archivos y donde pondra los archivos que guardes.\nPara verificar la ruta de tu directorio de trabajo simplemente puedes ver en la parte superior del panel de Consola.\nTambién puedes usar la función getwd() el cual arroja la ruta del directorio de trabajo\n\ngetwd()\n\n[1] \"C:/Users/migue/OneDrive/Documentos/Cursos/CIBNOR-Transcriptomica/2024/RNAseq2024\"\n\n\nSi quieres especificar una ruta como directorio de trabajo, entonces tienes que usar la función setwd(). Por ejemplo\n\nsetwd(\"Nueva/Ruta/de/trabajo\")\n\n\n\n\n\n\n\nTip\n\n\n\n#Establecer directorio de trabajo\nOtra manera sencilla de establecer un directorio de trabajo es navegando en el panel de Archivos y una vez que te ubiques en la carpeta deseada y selecciona More &gt;&gt; Establecer como directorio de trabajo"
  },
  {
    "objectID": "1_Proyectos.html#directorios-de-trabajo",
    "href": "1_Proyectos.html#directorios-de-trabajo",
    "title": "Importar y exportar datos",
    "section": "",
    "text": "El directorio de trabajo es la ubicación por defecto donde R estará buscando archivos y donde pondra los archivos que guardes.\nPara verificar la ruta de tu directorio de trabajo simplemente puedes ver en la parte superior del panel de Consola.\nTambién puedes usar la función getwd() el cual arroja la ruta del directorio de trabajo\n\ngetwd()\n\n[1] \"C:/Users/migue/OneDrive/Documentos/Cursos/CIBNOR-Transcriptomica/2024/RNAseq2024\"\n\n\nSi quieres especificar una ruta como directorio de trabajo, entonces tienes que usar la función setwd(). Por ejemplo\n\nsetwd(\"Nueva/Ruta/de/trabajo\")\n\n\n\n\n\n\n\nTip\n\n\n\n#Establecer directorio de trabajo\nOtra manera sencilla de establecer un directorio de trabajo es navegando en el panel de Archivos y una vez que te ubiques en la carpeta deseada y selecciona More &gt;&gt; Establecer como directorio de trabajo"
  },
  {
    "objectID": "1_Proyectos.html#rutas-relativas-y-absolutas",
    "href": "1_Proyectos.html#rutas-relativas-y-absolutas",
    "title": "Importar y exportar datos",
    "section": "Rutas relativas y absolutas",
    "text": "Rutas relativas y absolutas\nComo ya hemos visto, cuando trabajamos con archivos en R, necesitamos especificar su ubicación en el sistma de archivos. Esto se puede hacer usando rutas absolutas o rutas relativas.\n\nRutas absolutas\nLas rutas absolutas es la ruta completa desde la raíz hasta el archivo y siempre será la misma, sin importar dónde se ejecute el código. Por ejemplo:\n\nEn Windows: C:/Users/Usuario/Documents/proyecto/datos.csv\nEn macOS/Linux: /home/usuario/proyecto/datos.csv\n\n\n\nRutas relativas\nUna ruta relativa especifica la ubicación del archivo en relación con el directorio de trabajo actual. Por ejemplo, si tu directorio de trabajo actual es C:/Users/Usuario/Documents, entonces la ruta relativa a datos.csv en el subdirectorio proyecto sería:\n\ndatos &lt;- read.csv(\"proyecto/datos.csv\")"
  },
  {
    "objectID": "1_Proyectos.html#importar-archivos-de-texto",
    "href": "1_Proyectos.html#importar-archivos-de-texto",
    "title": "Importar y exportar datos",
    "section": "Importar archivos de texto",
    "text": "Importar archivos de texto\nLa importación de archivos de texto es el primer paso y parte fundamental para la exploración de datos. Sin embargo, también puede llegar a ser una tarea complicada.\nLos tipos de archivos mas comunes con los que solemos trabajar son:\n\nArchivos separados por coma (csv)\nArchivos separados por tabulador (tsv)\nExcel (xls)\nArchivo de texto simple (txt)"
  },
  {
    "objectID": "1_Proyectos.html#funciones-base-para-importar-archivos",
    "href": "1_Proyectos.html#funciones-base-para-importar-archivos",
    "title": "Importar y exportar datos",
    "section": "Funciones base para importar archivos",
    "text": "Funciones base para importar archivos\nPara importar un archivo a nuestro ambiente podemos utilizar las funciones base read.table, read.csv, read.delim. Por ejemplo, para abrir un archivo txt separado por tabuladores utilizando la función:"
  },
  {
    "objectID": "1_Proyectos.html#proyectos-en-rstudio",
    "href": "1_Proyectos.html#proyectos-en-rstudio",
    "title": "Importar y exportar datos",
    "section": "Proyectos en Rstudio",
    "text": "Proyectos en Rstudio\nComo vimos en el apartado anterior, es posible establecer un directorio de trabajo al inicio de un código y posteriormente usar rutas relativas con respecto a ese directorio de trabajo.\nDe esta manera, independientemente de si estás dando tus primeros pasos en R o si ya eres un experto, es frecuente que la primera línea de tu código sea algo como esto:\n\nsetwd(\"C:\\Users\\miguel\\ruta\\que\\solo\\yo\\tengo\")\n\nEvidentemente, si quieres compartir tu código con otra persona, esta ruta no funcionará ya que ese directorio no existe en su computadora.\nLos proyectos de RStudio resuelven el problema de las rutas ‘frágiles’ al hacer que las rutas de archivo sean relativas. El archivo de proyecto de RStudio es un archivo que se encuentra en el directorio raíz, con la extensión .Rproj. Cuando tu sesión de RStudio está siendo ejecutada a través del archivo de proyecto (.Rproj), el directorio de trabajo actual apunta a la carpeta raíz donde se guarda ese archivo .Rproj.\nEste proyecto facilita importar y exportar archivos ya que todos están a la mano a partir de rutas relativas a la carpeta raíz.\n\n\n\n\n\n\nTip\n\n\n\nOtra gran ventaja de los proyectos de Rstudio, es que puedes compartirlo con otra persona manteniendo la estructura de las rutas relativas, de manera que no importa en donde se guarde el proyecto o si esta utilizando otro sistema operativo, las rutas relativas permanecen funcionales siempre y cuando abra la sesión utilizando el proyecto (.Rproj).\n\n\nUn ejemplo de como podemos estructurar un proyecto es el siguiente:\n\n\n\n\n\n\nDatos: Esta es la carpeta en la que se guardan los archivos que necesito leer en R para realizar mi análisis o visualización. Estos pueden ser CSV, TXT, TSV, etc. La idea principal de tener esta carpeta es que estos archivos crudos en ningún momento debería sobrescribir o editar para garantizar la reproducibilidad.\nScript: Aquí es donde puedes guardar los scripts de R y/o archivos RMarkdown o Quarto.\nSalida: En esta carpeta puedes guardar todas tus salidas, incluyendo gráficos, HTML y tablas, etc. Tener esta carpeta de Salida ayuda a otros a identificar qué archivos son resultados del código, en contraste con los archivos fuente que se utilizaron para producir el análisis."
  },
  {
    "objectID": "1_Rproyectos.html",
    "href": "1_Rproyectos.html",
    "title": "Proyectos de Rstudio",
    "section": "",
    "text": "El directorio de trabajo es la ubicación por defecto donde R estará buscando archivos y donde pondra los archivos que guardes.\nPara verificar la ruta de tu directorio de trabajo simplemente puedes ver en la parte superior del panel de Consola.\nTambién puedes usar la función getwd() el cual arroja la ruta del directorio de trabajo\n\ngetwd()\n\n[1] \"C:/Users/migue/OneDrive/Documentos/Cursos/CIBNOR-Transcriptomica/2024/RNAseq2024\"\n\n\nSi quieres especificar una ruta como directorio de trabajo, entonces tienes que usar la función setwd(). Por ejemplo\n\nsetwd(\"Nueva/Ruta/de/trabajo\")\n\n\n\n\n\n\n\nTip\n\n\n\n#Establecer directorio de trabajo\nOtra manera sencilla de establecer un directorio de trabajo es navegando en el panel de Archivos y una vez que te ubiques en la carpeta deseada y selecciona More &gt;&gt; Establecer como directorio de trabajo",
    "crumbs": [
      "Inicio",
      "Proyectos de Rstudio"
    ]
  },
  {
    "objectID": "1_Rproyectos.html#directorios-de-trabajo",
    "href": "1_Rproyectos.html#directorios-de-trabajo",
    "title": "Proyectos de Rstudio",
    "section": "",
    "text": "El directorio de trabajo es la ubicación por defecto donde R estará buscando archivos y donde pondra los archivos que guardes.\nPara verificar la ruta de tu directorio de trabajo simplemente puedes ver en la parte superior del panel de Consola.\nTambién puedes usar la función getwd() el cual arroja la ruta del directorio de trabajo\n\ngetwd()\n\n[1] \"C:/Users/migue/OneDrive/Documentos/Cursos/CIBNOR-Transcriptomica/2024/RNAseq2024\"\n\n\nSi quieres especificar una ruta como directorio de trabajo, entonces tienes que usar la función setwd(). Por ejemplo\n\nsetwd(\"Nueva/Ruta/de/trabajo\")\n\n\n\n\n\n\n\nTip\n\n\n\n#Establecer directorio de trabajo\nOtra manera sencilla de establecer un directorio de trabajo es navegando en el panel de Archivos y una vez que te ubiques en la carpeta deseada y selecciona More &gt;&gt; Establecer como directorio de trabajo",
    "crumbs": [
      "Inicio",
      "Proyectos de Rstudio"
    ]
  },
  {
    "objectID": "1_Rproyectos.html#rutas-relativas-y-absolutas",
    "href": "1_Rproyectos.html#rutas-relativas-y-absolutas",
    "title": "Proyectos de Rstudio",
    "section": "Rutas relativas y absolutas",
    "text": "Rutas relativas y absolutas\nComo ya hemos visto, cuando trabajamos con archivos en R, necesitamos especificar su ubicación en el sistma de archivos. Esto se puede hacer usando rutas absolutas o rutas relativas.\n\nRutas absolutas\nLas rutas absolutas es la ruta completa desde la raíz hasta el archivo y siempre será la misma, sin importar dónde se ejecute el código. Por ejemplo:\n\nEn Windows: C:/Users/Usuario/Documents/proyecto/datos.csv\nEn macOS/Linux: /home/usuario/proyecto/datos.csv\n\n\n\nRutas relativas\nUna ruta relativa especifica la ubicación del archivo en relación con el directorio de trabajo actual. Por ejemplo, si tu directorio de trabajo actual es C:/Users/Usuario/Documents, entonces la ruta relativa a datos.csv en el subdirectorio proyecto sería:\n\ndatos &lt;- read.csv(\"proyecto/datos.csv\")",
    "crumbs": [
      "Inicio",
      "Proyectos de Rstudio"
    ]
  },
  {
    "objectID": "1_Rproyectos.html#proyectos-en-rstudio",
    "href": "1_Rproyectos.html#proyectos-en-rstudio",
    "title": "Proyectos de Rstudio",
    "section": "Proyectos en Rstudio",
    "text": "Proyectos en Rstudio\nComo vimos en el apartado anterior, es posible establecer un directorio de trabajo al inicio de un código y posteriormente usar rutas relativas con respecto a ese directorio de trabajo.\nDe esta manera, independientemente de si estás dando tus primeros pasos en R o si ya eres un experto, es frecuente que la primera línea de tu código sea algo como esto:\n\nsetwd(\"C:\\Users\\miguel\\ruta\\que\\solo\\yo\\tengo\")\n\nEvidentemente, si quieres compartir tu código con otra persona, esta ruta no funcionará ya que ese directorio no existe en su computadora.\nLos proyectos de RStudio resuelven el problema de las rutas ‘frágiles’ al hacer que las rutas de archivo sean relativas. El archivo de proyecto de RStudio es un archivo que se encuentra en el directorio raíz, con la extensión .Rproj. Cuando tu sesión de RStudio está siendo ejecutada a través del archivo de proyecto (.Rproj), el directorio de trabajo actual apunta a la carpeta raíz donde se guarda ese archivo .Rproj.\nEste proyecto facilita importar y exportar archivos ya que todos están a la mano a partir de rutas relativas a la carpeta raíz.\n\n\n\n\n\n\nTip\n\n\n\nOtra gran ventaja de los proyectos de Rstudio, es que puedes compartirlo con otra persona manteniendo la estructura de las rutas relativas, de manera que no importa en donde se guarde el proyecto o si esta utilizando otro sistema operativo, las rutas relativas permanecen funcionales siempre y cuando abra la sesión utilizando el proyecto (.Rproj).\n\n\nUn ejemplo de como podemos estructurar un proyecto es el siguiente:\n\n\n\n\n\n\nDatos: Esta es la carpeta en la que se guardan los archivos que necesito leer en R para realizar mi análisis o visualización. Estos pueden ser CSV, TXT, TSV, etc. La idea principal de tener esta carpeta es que estos archivos crudos en ningún momento debería sobrescribir o editar para garantizar la reproducibilidad.\nScript: Aquí es donde puedes guardar los scripts de R y/o archivos RMarkdown o Quarto.\nSalida: En esta carpeta puedes guardar todas tus salidas, incluyendo gráficos, HTML y tablas, etc. Tener esta carpeta de Salida ayuda a otros a identificar qué archivos son resultados del código, en contraste con los archivos fuente que se utilizaron para producir el análisis.",
    "crumbs": [
      "Inicio",
      "Proyectos de Rstudio"
    ]
  },
  {
    "objectID": "1_Rproyectos.html#importar-archivos-de-texto",
    "href": "1_Rproyectos.html#importar-archivos-de-texto",
    "title": "Importar y exportar datos",
    "section": "Importar archivos de texto",
    "text": "Importar archivos de texto\nLa importación de archivos de texto es el primer paso y parte fundamental para la exploración de datos. Sin embargo, también puede llegar a ser una tarea complicada.\nLos tipos de archivos mas comunes con los que solemos trabajar son:\n\nArchivos separados por coma (csv)\nArchivos separados por tabulador (tsv)\nExcel (xls)\nArchivo de texto simple (txt)",
    "crumbs": [
      "Inicio",
      "Importar y exportar datos"
    ]
  },
  {
    "objectID": "1_Rproyectos.html#funciones-base-para-importar-archivos",
    "href": "1_Rproyectos.html#funciones-base-para-importar-archivos",
    "title": "Importar y exportar datos",
    "section": "Funciones base para importar archivos",
    "text": "Funciones base para importar archivos\nPara importar un archivo a nuestro ambiente podemos utilizar las funciones base read.table, read.csv, read.delim. Por ejemplo, para abrir un archivo txt separado por tabuladores utilizando la función:",
    "crumbs": [
      "Inicio",
      "Importar y exportar datos"
    ]
  },
  {
    "objectID": "1_Rimportar.html",
    "href": "1_Rimportar.html",
    "title": "Importar y exportar datos",
    "section": "",
    "text": "La importación de archivos de texto es el primer paso y parte fundamental para la exploración de datos. Sin embargo, también puede llegar a ser una tarea complicada.\nLos tipos de archivos mas comunes con los que solemos trabajar son:\n\nArchivos separados por coma (csv)\nArchivos separados por tabulador (tsv)\nExcel (xls)\nArchivo de texto simple (txt)",
    "crumbs": [
      "Inicio",
      "Importar y exportar datos"
    ]
  },
  {
    "objectID": "1_Rimportar.html#directorios-de-trabajo",
    "href": "1_Rimportar.html#directorios-de-trabajo",
    "title": "Importar y exportar datos",
    "section": "",
    "text": "El directorio de trabajo es la ubicación por defecto donde R estará buscando archivos y donde pondra los archivos que guardes.\nPara verificar la ruta de tu directorio de trabajo simplemente puedes ver en la parte superior del panel de Consola.\nTambién puedes usar la función getwd() el cual arroja la ruta del directorio de trabajo\n\ngetwd()\n\n[1] \"C:/Users/migue/OneDrive/Documentos/Cursos/CIBNOR-Transcriptomica/2024/RNAseq2024\"\n\n\nSi quieres especificar una ruta como directorio de trabajo, entonces tienes que usar la función setwd(). Por ejemplo\n\nsetwd(\"Nueva/Ruta/de/trabajo\")\n\n\n\n\n\n\n\nTip\n\n\n\n#Establecer directorio de trabajo\nOtra manera sencilla de establecer un directorio de trabajo es navegando en el panel de Archivos y una vez que te ubiques en la carpeta deseada y selecciona More &gt;&gt; Establecer como directorio de trabajo"
  },
  {
    "objectID": "1_Rimportar.html#rutas-relativas-y-absolutas",
    "href": "1_Rimportar.html#rutas-relativas-y-absolutas",
    "title": "Importar y exportar datos",
    "section": "Rutas relativas y absolutas",
    "text": "Rutas relativas y absolutas\nComo ya hemos visto, cuando trabajamos con archivos en R, necesitamos especificar su ubicación en el sistma de archivos. Esto se puede hacer usando rutas absolutas o rutas relativas.\n\nRutas absolutas\nLas rutas absolutas es la ruta completa desde la raíz hasta el archivo y siempre será la misma, sin importar dónde se ejecute el código. Por ejemplo:\n\nEn Windows: C:/Users/Usuario/Documents/proyecto/datos.csv\nEn macOS/Linux: /home/usuario/proyecto/datos.csv\n\n\n\nRutas relativas\nUna ruta relativa especifica la ubicación del archivo en relación con el directorio de trabajo actual. Por ejemplo, si tu directorio de trabajo actual es C:/Users/Usuario/Documents, entonces la ruta relativa a datos.csv en el subdirectorio proyecto sería:\n\ndatos &lt;- read.csv(\"proyecto/datos.csv\")"
  },
  {
    "objectID": "1_Rimportar.html#proyectos-en-rstudio",
    "href": "1_Rimportar.html#proyectos-en-rstudio",
    "title": "Importar y exportar datos",
    "section": "Proyectos en Rstudio",
    "text": "Proyectos en Rstudio\nComo vimos en el apartado anterior, es posible establecer un directorio de trabajo al inicio de un código y posteriormente usar rutas relativas con respecto a ese directorio de trabajo.\nDe esta manera, independientemente de si estás dando tus primeros pasos en R o si ya eres un experto, es frecuente que la primera línea de tu código sea algo como esto:\n\nsetwd(\"C:\\Users\\miguel\\ruta\\que\\solo\\yo\\tengo\")\n\nEvidentemente, si quieres compartir tu código con otra persona, esta ruta no funcionará ya que ese directorio no existe en su computadora.\nLos proyectos de RStudio resuelven el problema de las rutas ‘frágiles’ al hacer que las rutas de archivo sean relativas. El archivo de proyecto de RStudio es un archivo que se encuentra en el directorio raíz, con la extensión .Rproj. Cuando tu sesión de RStudio está siendo ejecutada a través del archivo de proyecto (.Rproj), el directorio de trabajo actual apunta a la carpeta raíz donde se guarda ese archivo .Rproj.\nEste proyecto facilita importar y exportar archivos ya que todos están a la mano a partir de rutas relativas a la carpeta raíz.\n\n\n\n\n\n\nTip\n\n\n\nOtra gran ventaja de los proyectos de Rstudio, es que puedes compartirlo con otra persona manteniendo la estructura de las rutas relativas, de manera que no importa en donde se guarde el proyecto o si esta utilizando otro sistema operativo, las rutas relativas permanecen funcionales siempre y cuando abra la sesión utilizando el proyecto (.Rproj).\n\n\nUn ejemplo de como podemos estructurar un proyecto es el siguiente:\n\n\n\n\n\n\nDatos: Esta es la carpeta en la que se guardan los archivos que necesito leer en R para realizar mi análisis o visualización. Estos pueden ser CSV, TXT, TSV, etc. La idea principal de tener esta carpeta es que estos archivos crudos en ningún momento debería sobrescribir o editar para garantizar la reproducibilidad.\nScript: Aquí es donde puedes guardar los scripts de R y/o archivos RMarkdown o Quarto.\nSalida: En esta carpeta puedes guardar todas tus salidas, incluyendo gráficos, HTML y tablas, etc. Tener esta carpeta de Salida ayuda a otros a identificar qué archivos son resultados del código, en contraste con los archivos fuente que se utilizaron para producir el análisis."
  },
  {
    "objectID": "1_Rimportar.html#importar-archivos-de-texto",
    "href": "1_Rimportar.html#importar-archivos-de-texto",
    "title": "Importar y exportar datos",
    "section": "",
    "text": "La importación de archivos de texto es el primer paso y parte fundamental para la exploración de datos. Sin embargo, también puede llegar a ser una tarea complicada.\nLos tipos de archivos mas comunes con los que solemos trabajar son:\n\nArchivos separados por coma (csv)\nArchivos separados por tabulador (tsv)\nExcel (xls)\nArchivo de texto simple (txt)",
    "crumbs": [
      "Inicio",
      "Importar y exportar datos"
    ]
  },
  {
    "objectID": "1_Rimportar.html#funciones-base-para-importar-archivos",
    "href": "1_Rimportar.html#funciones-base-para-importar-archivos",
    "title": "Importar y exportar datos",
    "section": "Funciones base para importar archivos",
    "text": "Funciones base para importar archivos\n\nImportar usando ventanas\nRstudio permite importar un set de datos de forma muy sencilla dentro de su IDE. Para esto, tenemos que posicionarnos en la pantalla de ambiente Environment y seleccionar la opción de importar un set de datos Import Dataset\n\n\n\n\n\nUna vez seleccionado el archivo, tenemos la opción de seleccionar el tipo de separador, formato y encabezados de las columnas.\n\n\n\n\n\nAl concluir, el set de datos estará disponible en nuestro ambiente.\n\n\nImportar desde la línea de comando\nPara importar un archivo a nuestro ambiente podemos utilizar las funciones base de R mas relevantes que son read.table y read.csv. Por ejemplo, para abrir un archivo txt separado por tabuladores o csv separado por comas, respectivamente. utilizando la función:\nLa sintaxis básica de read.table es la siguiente\n\ndata &lt;- read.table(\"ruta/del/archivo.txt\", header = TRUE, sep = \"\\t\")\n\n\nfile: Ruta del archivo que quieres importar.\nheader: Indica si el archivo tiene una fila de encabezado. Si es TRUE, la primera fila se usará como nombres de columnas.\nsep: Especifica el delimitador de los valores. Por ejemplo, \"\\t\" para archivos separados por tabulaciones o \",\" para comas.\n\nPor otro lado, read.csv cumple con la misma función que read.table solo que es mas especifica para archivos separados por coma, por lo que no es necesario incluir el parámetro sep.\n\n\n\n\n\n\nEjercicio\n\n\n\nUtilizando la función read.table o read.csvabre el archivo dataset_Pomemon.csv que descargaste previamente en la carpeta de datos\n\n\n\n\nImportar archivos desde un URL\nTambién es posible importar set de datos que se encuentren en línea usando la dirección url. El proceso es el mismo y se puede utilizar tanto read.table como read.csv, solamente en lugar de indicar la ruta del archivo en un directorio local, se indica el url.\n\n\n\n\n\n\nEjercicio\n\n\n\nImporta a tu ambiente el archivo DET_test.txt disponible en el siguiente enlace:\nhttps://raw.githubusercontent.com/trippv/RNAseq2024/master/data/DET_test.txt\n\n\nver codigo\ndeg &lt;- read.table(file = \"https://raw.githubusercontent.com/trippv/RNAseq2024/master/data/DET_test.txt\",\n                  sep = \"\\t\", header = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nPuedes asignar la dirección url a un objeto y después usar ese objeto dentro de la función read.table. Por ejemplo:\n\nurl &lt;- \"www.muchosDatos.com\"\ndf &lt;- read.table(file = url, header = TRUE, sep = \",\")",
    "crumbs": [
      "Inicio",
      "Importar y exportar datos"
    ]
  },
  {
    "objectID": "1_Rimportar.html#exploración-de-datos",
    "href": "1_Rimportar.html#exploración-de-datos",
    "title": "Importar y exportar datos",
    "section": "Exploración de datos",
    "text": "Exploración de datos\nSi queremos echar un vistazo rápido al contenido de nuestra tabla podemos utilizar algunas funciones base como summary() que nos despliega un resumen de cada columna de nuestra tabla\n\nsummary(deg)\n\n  transcript            logFC               logCPM              LR          \n Length:66968       Min.   :-12.77959   Min.   :-1.8730   Min.   :  0.0000  \n Class :character   1st Qu.: -0.75187   1st Qu.:-0.1186   1st Qu.:  0.4067  \n Mode  :character   Median :  0.05418   Median : 1.4014   Median :  1.8677  \n                    Mean   :  0.13555   Mean   : 1.9249   Mean   :  5.0564  \n                    3rd Qu.:  0.89139   3rd Qu.: 3.4577   3rd Qu.:  5.8335  \n                    Max.   : 13.92717   Max.   :15.5331   Max.   :226.2396  \n     PValue             FDR           contrast          expression       \n Min.   :0.00000   Min.   :0.0000   Length:66968       Length:66968      \n 1st Qu.:0.01572   1st Qu.:0.0628   Class :character   Class :character  \n Median :0.17174   Median :0.3436   Mode  :character   Mode  :character  \n Mean   :0.29213   Mean   :0.3957                                        \n 3rd Qu.:0.52364   3rd Qu.:0.6983                                        \n Max.   :1.00000   Max.   :1.0000                                        \n\n\nLa función table() se utiliza para crear una tabla de frecuencias de los datos en un vector o conjunto de vectores. Genera una tabla con la frecuencia con la que aparecen las combinaciones de valores únicos en los vectores suministrados. Es útil para resumir datos categóricos o discretos y para visualizar distribuciones de frecuencia.\nPor ejemplo, si queremos saber cuantos de nuestros genes se sobre expresaron o reprimieron, podemos utilizar la función tabel() en la columna expression\n\ntable(deg$expression)\n\n\n down    up \n51855 15113",
    "crumbs": [
      "Inicio",
      "Importar y exportar datos"
    ]
  },
  {
    "objectID": "1_Rimportar.html#generar-un-subconjunto-de-datos",
    "href": "1_Rimportar.html#generar-un-subconjunto-de-datos",
    "title": "Importar y exportar datos",
    "section": "Generar un subconjunto de datos",
    "text": "Generar un subconjunto de datos\nA menudo queremos generar un subconjunto de datos que contengan los valores de un tratamiento determinado o que cumplan con una condición determinada.\nPara realizar esto, podemos utilizar dos métodos diferentes:\n\nUtilizando indices, tal como lo hicimos en la sección 1.\nUtilizando la función subset()\n\n\nSubconjunto con indices\nEn la sección 1 vimos como podemos filtrar datos que cumplan con una determinada condición en una matriz o data frame utilizando los indices [].\nPor ejemplo, si queremos filtrar aquellos transcritos con un valor P &lt; 0.001, podemos utilizar:\n\ndeg$FDR &lt; 0.001\n\nEntonces, si queremos filtrar la tabla deg que cumplan con esta condición, entonces tenemos que especificar lo siguiente:\n\nsub_deg &lt;- deg[deg$PValue &lt; 0.001, ] \nhead(sub_deg)\n\n                 transcript     logFC   logCPM       LR   PValue      FDR\n1 TRINITY_DN58348_c94_g1_i1 11.420646 8.774037 226.2396 3.94e-51 6.60e-47\n2  TRINITY_DN41876_c1_g1_i1 13.927167 4.360619 205.7162 1.18e-46 9.89e-43\n3  TRINITY_DN49189_c0_g1_i1 -8.953827 7.614606 179.7208 5.58e-41 3.11e-37\n4  TRINITY_DN63782_c0_g2_i1 -8.082504 5.763163 154.3743 1.92e-35 8.03e-32\n5 TRINITY_DN65222_c12_g2_i4  8.489764 4.367937 152.6882 4.48e-35 1.50e-31\n6  TRINITY_DN54408_c0_g1_i2  7.765242 8.034710 148.5546 3.59e-34 1.00e-30\n   contrast expression\n1 T1_vs_CTL         up\n2 T1_vs_CTL         up\n3 T1_vs_CTL       down\n4 T1_vs_CTL       down\n5 T1_vs_CTL         up\n6 T1_vs_CTL         up\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nRecuerda que cuando usamos indices, estos indican [filas, columnas] separadas por una coma. Por lo que si solamente queremos filtrar las filas con una determinada condición, dejamos el espacio de las columnas en blanco para indica que queremos seleccionar todas las columnas de la tabla\n\n\n\n\nOperadores & y |\nSi queremos filtrar nuestra tabla utilizando dos condiciones, por ejemplo transcritos que se sobre-expresaron (up) solamente en la condición T1_vs_CTL entonces utilizamos el operado &.\nEl operado &Es el operador lógico que indica “y”. Solo se seleccionarán las filas que cumplan ambas condiciones.\n\nsub_deg &lt;- deg[deg$contrast == \"T1_vs_CTL\" & deg$expression == \"up\", ]\nhead(sub_deg)\n\n                 transcript     logFC   logCPM       LR   PValue      FDR\n1 TRINITY_DN58348_c94_g1_i1 11.420646 8.774037 226.2396 3.94e-51 6.60e-47\n2  TRINITY_DN41876_c1_g1_i1 13.927167 4.360619 205.7162 1.18e-46 9.89e-43\n5 TRINITY_DN65222_c12_g2_i4  8.489764 4.367937 152.6882 4.48e-35 1.50e-31\n6  TRINITY_DN54408_c0_g1_i2  7.765242 8.034710 148.5546 3.59e-34 1.00e-30\n7  TRINITY_DN43718_c0_g1_i1  7.732693 4.834847 141.6420 1.16e-32 2.79e-29\n8  TRINITY_DN51077_c0_g1_i2  7.497678 8.851058 139.2879 3.81e-32 7.97e-29\n   contrast expression\n1 T1_vs_CTL         up\n2 T1_vs_CTL         up\n5 T1_vs_CTL         up\n6 T1_vs_CTL         up\n7 T1_vs_CTL         up\n8 T1_vs_CTL         up\n\n\nPor otro lado el operador | en R es un operador lógico que se utiliza para evaluar una de dos o más condiciones. Cuando aplicas | entre dos condiciones, el resultado será TRUE si cualquiera de las condiciones es verdadera. Si ambas condiciones son falsas, el resultado será FALSE.\nEntonces, si queremos filtrar los transcriotos que tengan un valor de log fold-change mayor a 5 o menor a -5 hacemos lo siguiente\n\nsub_deg &lt;- deg[deg$logFC &gt; 5 | deg$logFC &lt; -5, ]\nhead(sub_deg)\n\n                 transcript     logFC   logCPM       LR   PValue      FDR\n1 TRINITY_DN58348_c94_g1_i1 11.420646 8.774037 226.2396 3.94e-51 6.60e-47\n2  TRINITY_DN41876_c1_g1_i1 13.927167 4.360619 205.7162 1.18e-46 9.89e-43\n3  TRINITY_DN49189_c0_g1_i1 -8.953827 7.614606 179.7208 5.58e-41 3.11e-37\n4  TRINITY_DN63782_c0_g2_i1 -8.082504 5.763163 154.3743 1.92e-35 8.03e-32\n5 TRINITY_DN65222_c12_g2_i4  8.489764 4.367937 152.6882 4.48e-35 1.50e-31\n6  TRINITY_DN54408_c0_g1_i2  7.765242 8.034710 148.5546 3.59e-34 1.00e-30\n   contrast expression\n1 T1_vs_CTL         up\n2 T1_vs_CTL         up\n3 T1_vs_CTL       down\n4 T1_vs_CTL       down\n5 T1_vs_CTL         up\n6 T1_vs_CTL         up\n\n\n\n\nSubconjunto usando la función subset()\nDe igual manera podemos utilizar la función subset() para generar un subconjunto de datos a partir de determinada condición.\nPor ejemplo, para filtrar los transcritos con un valor de FDR &lt; 0.001 haremos lo siguiente\n\nsub_deg &lt;- subset(deg, FDR &lt; 0.001)\nhead(sub_deg)\n\n                 transcript     logFC   logCPM       LR   PValue      FDR\n1 TRINITY_DN58348_c94_g1_i1 11.420646 8.774037 226.2396 3.94e-51 6.60e-47\n2  TRINITY_DN41876_c1_g1_i1 13.927167 4.360619 205.7162 1.18e-46 9.89e-43\n3  TRINITY_DN49189_c0_g1_i1 -8.953827 7.614606 179.7208 5.58e-41 3.11e-37\n4  TRINITY_DN63782_c0_g2_i1 -8.082504 5.763163 154.3743 1.92e-35 8.03e-32\n5 TRINITY_DN65222_c12_g2_i4  8.489764 4.367937 152.6882 4.48e-35 1.50e-31\n6  TRINITY_DN54408_c0_g1_i2  7.765242 8.034710 148.5546 3.59e-34 1.00e-30\n   contrast expression\n1 T1_vs_CTL         up\n2 T1_vs_CTL         up\n3 T1_vs_CTL       down\n4 T1_vs_CTL       down\n5 T1_vs_CTL         up\n6 T1_vs_CTL         up\n\n\nY de igual manera podemos utilizar el operador & para filtrar con dos condiciones:\n\nsub_deg &lt;- subset(deg, contrast == \"T1_vs_CTL\" & \n                    expression == \"up\")\nhead(sub_deg)\n\n                 transcript     logFC   logCPM       LR   PValue      FDR\n1 TRINITY_DN58348_c94_g1_i1 11.420646 8.774037 226.2396 3.94e-51 6.60e-47\n2  TRINITY_DN41876_c1_g1_i1 13.927167 4.360619 205.7162 1.18e-46 9.89e-43\n5 TRINITY_DN65222_c12_g2_i4  8.489764 4.367937 152.6882 4.48e-35 1.50e-31\n6  TRINITY_DN54408_c0_g1_i2  7.765242 8.034710 148.5546 3.59e-34 1.00e-30\n7  TRINITY_DN43718_c0_g1_i1  7.732693 4.834847 141.6420 1.16e-32 2.79e-29\n8  TRINITY_DN51077_c0_g1_i2  7.497678 8.851058 139.2879 3.81e-32 7.97e-29\n   contrast expression\n1 T1_vs_CTL         up\n2 T1_vs_CTL         up\n5 T1_vs_CTL         up\n6 T1_vs_CTL         up\n7 T1_vs_CTL         up\n8 T1_vs_CTL         up",
    "crumbs": [
      "Inicio",
      "Importar y exportar datos"
    ]
  },
  {
    "objectID": "1_Rimportar.html#exportar-tablas",
    "href": "1_Rimportar.html#exportar-tablas",
    "title": "Importar y exportar datos",
    "section": "Exportar tablas",
    "text": "Exportar tablas\nDentro de nuestro análisis es común que tengamos que guardar nuestro conjunto de datos, ya sea que hayamos realizado algún tipo de análisis o que hayamos generado un subconjunto de datos que queremos guardar.\nPara exportar nuestros datos, vamos a utilizar la función write.table\n\nwrite.table(x = sub_deg, #objeto que queremos guardar\n            file = \"resultados/sub_deg.csv\", #ruta\n            sep = \",\", #tipo de separador\n            row.names = FALSE, #¿usar rownames?\n            )\n\n\n\n\n\n\n\nEjercicio\n\n\n\nUtilizando lo que hemos aprendido hasta este momento, genera las siguientes tablas y guardalas en tu carpeta de resultados:\n\nTabla con los resultados de transcritos expresados diferencialmente con un valor de FDR &lt; 0.05 del contraste T2_vs_CTL.\nTabla con transcritos sobre-expresados con un valor de log fold-change &gt; 5 y un valor de FDR &lt; 0.01.\n\n\n\nver codigo\ne.1 &lt;- deg[deg$contrast == \"T2_vs_CTL\" & \n             deg$FDR &lt; 0.05, ]\n\ne.2 &lt;- deg[deg$logFC &gt; 5 & deg$FDR &lt; 0.01, ]\n\n# exportar tablas\n## e1\nwrite.table(e.1, \n            \"resultados/ejercicio_E1.csv\",\n            sep = \",\")\n## e2\nwrite.table(e.2, \n            \"resultados/ejercicio_E2.csv\",\n            sep = \",\")",
    "crumbs": [
      "Inicio",
      "Importar y exportar datos"
    ]
  },
  {
    "objectID": "3_control_calidad.html",
    "href": "3_control_calidad.html",
    "title": "Control de Calidad",
    "section": "",
    "text": "Desde tu /home/ crea el directorio de trabajo transcriptomica y accede a el.\nmkdir transcriptomica \ncd transcriptomica"
  },
  {
    "objectID": "3_control_calidad.html#lecturas-de-prueba",
    "href": "3_control_calidad.html#lecturas-de-prueba",
    "title": "Control de Calidad",
    "section": "Lecturas de prueba",
    "text": "Lecturas de prueba\nAntes de análizar las secuencias de nuestro estudio, vamos a ver unos ejemplos de cálidad de secuencias. Estas secuencias se obtuvieron de bases de datos publicas.\n\n\n\n\n\n\nWarning\n\n\n\nOjo: Estas lecturas solo son una submuestra de las originales, por lo que son mucho mas pequeñas.\n\n\n\nCreamos una carpeta parental llamada fastqc_test y dentro de esta, generamos las carpetas secuencias, fastqc_pre y fastqc_post.\n\n\nmkdir -p fastqc_test/{secuencias,fastqc_pre,fastqc_post}\n\n\nDentro de la carpeta secuenciasvamos a crear un link simbólico de las secuencias que serán utilizadas.\n\n\nRecuerda la sintaxis:\nln -s ORIGEN DESTINO\n\n\ncd fastqc_test/secuencias\nln -s /home/mtripp/CURSO_RNASEQ2024/fastqc_test/secuencias/*.gz ./\nls\n\n\n\n\n\n\n\n¿Como saber cuantas lecturas tiene cada archivo?\n\n\n\nPodemos utilizar la función grep para buscar un caracter en común de todas las lecturas y hacer pipe para contar el número de lineas que tienen ese caracter\nPor ejemplo: las lectutas SRR7096024_1.fastq, podemos utilizar el ID @SRR7096024_1\n\nzcat SRR7096024_1.fastq.gz | grep \"^@SRR70\" | wc -l\n\n\n\n\nPosteriormente ejecutamos FASTQC. Para esto nos vamos a colocar en la carpeta fastqc_pre y generamos el siguiente script.\n\n\nfastqc ./*.fastq.gz -t 8 -o ./\n\nEsto nos generará un archivo .html por cada lectura.\n\nDescargamos los reportes HTML generados a nuestra computadora en la carpeta de trabajo para revisarlo. Para esto, abrimos una nueva ventana de la terminal y vamos a generar una estructura de directorios igual que en omica\n\n\ncd transcriptomica \nmkdir -p fastqc_test/{fastqc_pre,fastqc_post}\ncd fastqc_pre\n\n\n\n\n\n\n\nNota\n\n\n\nRecuerda la sintaxis:\n\nscp curso##@omica:ruta/de/la/carpeta/*.html ./\n\n\n\n\nRevisión individual de archivos .html en navegador firefox o en el navegador que tengan instalado, para verificar la calidad de las lecturas de secuenciación.\n\n\nfirefox SRR10858532_1_fastqc.html\nfirefox SRR10858532_2_fastqc.html\n\n\n\n\n\n\n\nNote\n\n\n\nSi estas utilizando ubuntu app, dentro de la carpeta de trabajo ejecuta:\nexplorer.exe SRR10858532_1_fastqc.html\n\n\n\nRevisa cada uno de los reportes y discute cuales son las diferencias entre la calidad de las lecturas"
  },
  {
    "objectID": "3_control_calidad.html#limpieza-y-control-de-calidad-de-las-lecturas",
    "href": "3_control_calidad.html#limpieza-y-control-de-calidad-de-las-lecturas",
    "title": "Control de Calidad",
    "section": "2. Limpieza y control de calidad de las lecturas",
    "text": "2. Limpieza y control de calidad de las lecturas\nAhora utilizaremos el Programa Trimmomatic para cortar y filtrar las lecturas con baja calidad asi como eliminar adaptadores en las lecturas.\nPara correr Trimmomatic crearemos un código bash donde indicaremos los archivos que vamos a procesar. El procedimiento es el siguiente:\n\nCrear la carpeta trimmomatic en la carpeta dentro de la carpeta de fastqc_test y acceder a ella.\n\n\ncd ..\nmkdir trimmomatic\ncd trimmomatic\n\n\nGenerar el script al cual llamaremos trimmomatic.sh\n\n\nnano trimmomatic.sh\n\n\n\n\n\n\n\nImportante\n\n\n\nNo se te olvide que tienes que tener activado el ambiente de conda de trinity\n\nconda activate trinity\n\n\n\nEl archivo bash debe contener lo siguiente:\n\n#!/bin/bash\n\n# ruta aal archivo fasta con las secuencias de los adaptadores\ntrueseq=\"/home/mtripp/CURSO_RNASEQ2024/trimmomatic/adapters/TruSeq3-PE.fa\" \n\n# Define los archivos donde se guardarán los mensajes y errores del proceso.\nLOG_FILE=\"trimmomatic.log\"  # Aquí se guarda el registro de lo que hace el programa\nERR_FILE=\"trimmomatic.err\"  # Aquí se guardan los errores si ocurre algún problema\n\n\ntrimmomatic PE -threads 4 ../secuencias/SRR7096024_1.fastq.gz ../secuencias/SRR7096024_2.fastq.gz \\\n -baseout trimmed_SRR7096024.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36 \\\n1&gt;&gt; $LOG_FILE 2&gt;&gt; $ERR_FILE\n\ntrimmomatic PE -threads 4 ../secuencias/SRR10858532_1.fastq.gz ../secuencias/SRR10858532_2.fastq.gz \\\n -baseout trimmed_SRR10858532.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36 \\\n   1&gt;&gt; $LOG_FILE 2&gt;&gt; $ERR_FILE\n\ntrimmomatic PE -threads 4 ../secuencias/rv06m_S8_L001_1.fastq.gz ../secuencias/rv06m_S8_L001_2.fastq.gz \\\n-baseout trimmed_rv06m_S8_L001.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36 \\\n  1&gt;&gt; $LOG_FILE 2&gt;&gt; $ERR_FILE\n\n\nCambia los permisos de ejecución del código con el siguiente comando:\n\n\nchmod +x trimmomatic.sh\n\n\nFInalmente ejecuta el código\n\n\n./trimmomatic.sh\n\n\nGenerar dos carpetas para colocar las lecturas Paired y las Unpaired. Posteriormente, mueve todas las lecturas a sus respectivas carpetas usando el comando mv\n\n\nmkdir trimm_u\nmkdir trimm_p\n\nmv *P.fastq.gz trimm_p/\nmv *U.fastq.gz trimm_u/\n\n\nAhora evalua la calidad de estas lecturas limpias con FastQC dentro de la carpeta fastqc_test/fastqc_post.\n\n\ncd ../../fastqc_post\nfastqc ../trimmomatic/trimm_p/*.fastq.gz -t 8 -o ./\n\n\nFinalmente, transfiere los reportes nuevos a tu computadora para revisarlos\nAhora vamos a repetir los pasos del 3 al 7 pero con la misma muestra pero usando parametros mas riguroso:\nGenerar el script al cual llamaremos trimmomatic_rig.slrm\n\n\nnano trimmomatic_rig.sh\n\nEl script debe contener lo siguiente:\n\njava -jar $TRIM/trimmomatic-0.36.jar PE ../SRR7096024_1.fastq ../SRR7096024_2.fastq -baseout trimmed_rig_SRR7096024.fastq \\\nILLUMINACLIP:TruSeq3-PE-2.fa:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:20 MINLEN:36 HEADCROP:5\n\nexit 0\n\nTransfiere los archivos a tu computadora para visualizarlos. Discute los principales cambios\n\nFinalmente, corre los pasos del 3 al 7 incluyendo todas las muestras."
  },
  {
    "objectID": "3_control_calidad.html#análisis-de-calidad-de-las-lecturas-con-fastqc-y-multiqc",
    "href": "3_control_calidad.html#análisis-de-calidad-de-las-lecturas-con-fastqc-y-multiqc",
    "title": "Control de Calidad",
    "section": "2.1 Análisis de calidad de las lecturas con FastQC y MultiQC",
    "text": "2.1 Análisis de calidad de las lecturas con FastQC y MultiQC\n\nFASTQC\nAl igual que como lo hicimos en nuestro ejercicio anterior; en la carpeta de transcriptomica, vamos a crear carpeta fastqc y con las subcarpetas fastqc_pre y fastqc_post. Acceder a carpeta fastqc_pre\n\ncd ..\nmkdir -p fastqc/{fastqc_pre,fastqc_post}\ncd fastqc/fastqc_pre\n\nRealizar análisis de calidad de las secuencias con el programa Fastqc. Se obtendrán N archivos .html y fastqc.zip.\n\nfastqc ../../reads/*.gz -t 8 -o ./\n\nComo puedes darte cuenta, la cantidad de archivos resultantes en este estudio es mayor por lo que es poco práctico revisarlos uno por uno. Para esto, utilizaremos otra herramienta; MultiQC\n\n\nMULTIQC\nSi se quiere hacer una comparación entre todos los valores de calidad de las secuencias, se puede utilizar el programa MultiQC que utiliza los archivos generados por FastQC. Se requiere un ambiente para el programa que está basado en python 2.7\n\n\n\n\n\n\nImportant\n\n\n\nPara poder utilizar MultiQC es necesario cargar el modulo conda multiqc\n\nconda activate multiqc\n\n\n\nejecuta multiqc -h para que se despliegue la lista de parámetros que Multiqc necesita para ejecutarse\nDentro de la carpeta de FASTQ_PRE crear una carpeta llamada MULTIQC. Entramos a esta carpeta y corremos MultiQC activando el ambiente multiqc_py2.7. Se generaran las carpetas multiqc_data, multiqc_plots y multiqc_reports.html. Revisar archivo .html. Al finalizar desactivar el ambiente multiqc_py2.7.\n\n$ mkdir MULTIQC\n$ cd MULTIQC/\n$ multiqc ../*.zip -o ./ --data-format tsv --export --title \"Analisis pre trimming\"\n\n\n$ source deactivate multiqc_py2.7\n\nRevisar el archivo .html obtenido con MultiQC dentro de la carpeta PRE y descargarlo a su computadora personal siguiendo los pasos descritos anteriormente\n\n\ncd Documentos/curso2022/transrciptomica/FASTQC_PRE\nmkdir Multiqc\ncd Multiqc\nscp curso01@omica:/home/curso01/curso2022/trascriptomica/FASTQC/FASTQC_PRE/Multiqc/multiqc_report.html ./\n   \n\n3. Revisar el archivo .hmtl obtenido con el programa MultiQC\n\nfirefox multiqc_report.html\n\n4. Cerrar esta terminal en cuanto se termine de revisar el archivo .html"
  },
  {
    "objectID": "3_control_calidad.html#limpieza-y-eliminación-de-lecturas-de-mala-calidad-con-trimmomatic",
    "href": "3_control_calidad.html#limpieza-y-eliminación-de-lecturas-de-mala-calidad-con-trimmomatic",
    "title": "Control de Calidad",
    "section": "2.2. Limpieza y eliminación de lecturas de mala calidad con Trimmomatic",
    "text": "2.2. Limpieza y eliminación de lecturas de mala calidad con Trimmomatic\n\n\n\n\n\n\nWarning\n\n\n\nComo utilizaremos trimmomatic con un archivo slurm en este punto debes salir del nodo\n\n\nEn este paso se usará el programa Trimmomatic, para eliminar las secuencias de mala calidad, así como índices o adaptadores de secuenciación que pudieran haber quedado.\nCrear la carpeta TRIMMOMATIC en la carpeta transcriptomica y acceder a ella.\n\ncd ../../\nmkdir TRIMMOMATIC\ncd TRIMMOMATIC\n\nGenerar el script al cual llamaremos trimmomatic.slrm\n\nnano trimmomatic.slrm\n\nEl slrm debe contener lo siguiente:\n\n#!/bin/bash\n#########################################################\n#TRIMOMMATIC\n\n## Directivas\n#SBATCH --job-name=qtrim\n#SBATCH --output=trimmomatic-%j.log\n#SBATCH --error=trimmomatic-%j.err\n#SBATCH -N 1\n#SBATCH --mem=20GB\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n#SBATCH -p cicese\n\n\n# Ruta a TRIMMOMATIC\nTRIMMOMATIC=/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trimmomatic-0.36\n\n#Ruta al archivo con los adaptadores\ntrueseq=\"$TRIMMOMATIC/adapters/TruSeq3-PE-2.fa\"\n\n\ncd ${SLURM_SUBMIT_DIR}\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/Ctrl_rep1_500k_R1.fastq.gz ../RAW_READS/Ctrl_rep1_500k_R2.fastq.gz -baseout Ctrl_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/Ctrl_rep2_500k_R1.fastq.gz ../RAW_READS/Ctrl_rep2_500k_R2.fastq.gz -baseout Ctrl_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T1_rep1_500k_R1.fastq.gz ../RAW_READS/T1_rep1_500k_R2.fastq.gz -baseout T1_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T1_rep2_500k_R1.fastq.gz ../RAW_READS/T1_rep2_500k_R2.fastq.gz -baseout T1_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T2_rep1_500k_R1.fastq.gz ../RAW_READS/T2_rep1_500k_R2.fastq.gz -baseout T2_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T2_rep2_500k_R1.fastq.gz ../RAW_READS/T2_rep2_500k_R2.fastq.gz -baseout T2_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T3_rep1_500k_R1.fastq.gz ../RAW_READS/T3_rep1_500k_R2.fastq.gz -baseout T3_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T3_rep2_500k_R1.fastq.gz ../RAW_READS/T3_rep2_500k_R2.fastq.gz -baseout T3_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\nexit 0\n\nCorrer el script trimmomatic.slrm\n\nsbatch trimmomatic.slrm\nsqueue\n\nCrear carpetas TRIM_P y TRIM_U y mover los archivos que correspondan a cada carpeta.\n\nls \nmkdir TRIM_P TRIM_U\nmv *U.fastq.gz TRIM_U/\nmv *P.fastq.gz TRIM_P/\nls \nls TRIM_P/\n\nAhora se recomienda revisar las secuencias pareadas con FastQC y MultiQC como se realizó en los pasos anteriores. Para ello deben moverse a la carpeta FASTQC_POST para correr el script.\n\ncd ../FASTQC/FASTQC_POST/\nfastqc -t 8 ../../TRIMMOMATIC/TRIM_P/*.fastq.gz -o ./               \nls \n\nCorrer el script de MultiQC en la carpeta respectiva y checar archivo .html\n\ncd ../../MULTIQC/POST\nsource activate multiqc_py2.7\nmultiqc ../../FASTQC/FASTQC_POST/*.zip -o ./ --data-format json --export\n\n\nsource deactivate multiqc_py2.7\n\nRevisar el archivo .html obtenido con MultiQC dentro de la carpeta POST.\nCerrar esta terminal en cuanto se termine de revisar el archivo .html\n\nEn caso de haber problemas con las rutas de los programas, se puede generar un bash_profile con las rutas de todos los programas:\nPegar en el .bash_profile los paths de los programas que serán utilizados durante el curso.\n\nnano .bash_profile\n\nPegar los siguientes path de los programas que serán utilizados durante el análisis transcriptómico.\n\n# Software for transcriptomic analysis\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/FastQC_v0.11.7\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trimmomatic-0.36\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/util\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/Analysis/DifferentialExpression\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/trinity-plugins/parafly-code/bin\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/trinity-plugins/parafly/bin\nexport R_LIBRARY_PATH=/LUSTRE/apps/R-3.3.1/lib64/R/library\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/ncbi-blast-2.4.0+/bin\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/TransDecoder-3.0.1\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/RNA/ricardo/bioinformatics/transdecoder\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/signalp-4.1\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/tmhmm-2.0c/bin\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trinotate/util/rnammer_support\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/rnammer\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/hmmer-3.1b2-linux-intel-x86_64/binaries\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/Trinotate/PerlLib\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/Trinotate/auto\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/samtools-1.7/bin\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/bowtie2\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/RSEM\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/Laura/bin/transrate-1.0.3-linux-x86_64/transrate\n\nActualizar el archivo .bash_profile\n\nsource .bash_profile"
  },
  {
    "objectID": "1_Rpaquetes.html",
    "href": "1_Rpaquetes.html",
    "title": "Uso de librerias y funciones",
    "section": "",
    "text": "Un paquete, o libreria, es un conjunto de funciones, datos y documentación que esta diseñado para realizar tareas especificas, extendiendo las capacidades del lenguaje R.\nEstos paquetes son fundamentales para realizas tareas que van desde la manipulación y visualización de datos, hasta modelos estadisticos complejos.\n\n\n\n\n\n\n¿Quien crea los paquetes? 🤷‍♂️\n\n\n\nCualquier persona puede crear un paquete que realiza una o varias tareas en especifico.\n\n\nExisten paquetes, como por ejemplo tidyverse que son desarrollados por un conjunto de colaboradores pertenecientes a empresas o grupos de investigación los cuales estan en contante manteniemiento y estan disponibles desde repositorios publicos como CRAN. Pero también hay paquetes que son desarrollados por individuos y que pueden ser desacargados desde repositorios personales como github."
  },
  {
    "objectID": "1_Rpaquetes.html#uso-de-paquetes-en-r",
    "href": "1_Rpaquetes.html#uso-de-paquetes-en-r",
    "title": "Uso de librerias y funciones",
    "section": "",
    "text": "Un paquete, o libreria, es un conjunto de funciones, datos y documentación que esta diseñado para realizar tareas especificas, extendiendo las capacidades del lenguaje R.\nEstos paquetes son fundamentales para realizas tareas que van desde la manipulación y visualización de datos, hasta modelos estadisticos complejos.\n\n\n\n\n\n\n¿Quien crea los paquetes? 🤷‍♂️\n\n\n\nCualquier persona puede crear un paquete que realiza una o varias tareas en especifico.\n\n\nExisten paquetes, como por ejemplo tidyverse que son desarrollados por un conjunto de colaboradores pertenecientes a empresas o grupos de investigación los cuales estan en contante manteniemiento y estan disponibles desde repositorios publicos como CRAN. Pero también hay paquetes que son desarrollados por individuos y que pueden ser desacargados desde repositorios personales como github."
  },
  {
    "objectID": "1_Rpaquetes.html#instalación-y-carga-de-paquetes",
    "href": "1_Rpaquetes.html#instalación-y-carga-de-paquetes",
    "title": "Uso de librerias y funciones",
    "section": "Instalación y carga de paquetes",
    "text": "Instalación y carga de paquetes\nLos paquetes se instalan una vez y se pueden utilizar en cualquier sesión de R. La función install.package() se usa para instalar paquetes desde CRAN (el repositorio de paquetes de R) u otras fuentes.\nPor ejemplo, para instalar un paquetes como ggplot2 hacemos lo siguiente:\n\ninstall.packages(\"ggplot2\")\n\n\n\n\n\n\n\n\n\nCRAN\n\n\n\nCRAN es una red de servidores distribuidos globalmente que almacena y distribuye paquetes de software para R. Estos paquetes son colecciones de funciones, datos y documentación que se pueden instalar y usar dentro del entorno de R para realizar tareas específicas.\n\n\nUna vez instalado el paquete, este se debe de cargar en cada sesión de R usando la función library() o requiere()\n\nlibrary(ggplot2)\n\nHecho esto, las funciones y/o bases de datos contenidas en el paquete se cargaran en tu entorno actual.\nEs importante tener en mente que cada que inicies una nueva sesión en R, debes cargar el paquete con lirbary() de lo contrario, las funciones no estaran disponibles.\nLos paquetes que hemos importado en nuestra sesión actual aparecen al llamar sessionInfo()\n\nsessionInfo()\n\nR version 4.3.0 (2023-04-21 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19045)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Chihuahua\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.0    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.3.0       htmltools_0.5.5   rstudioapi_0.15.0 yaml_2.3.7       \n [9] rmarkdown_2.22    knitr_1.43        jsonlite_1.8.7    xfun_0.39        \n[13] digest_0.6.31     rlang_1.1.1       evaluate_0.23"
  }
]