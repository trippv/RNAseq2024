[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "texto de prueba"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RNAseq2024",
    "section": "",
    "text": "Date: Date and time\nLugar: Centro de Investigaciones Biológicas del Noroeste, S.C.\nInstructores: Miguel A. Tripp Valdez, Pavel E. Galindo Torres"
  },
  {
    "objectID": "index.html#temario-del-curso",
    "href": "index.html#temario-del-curso",
    "title": "RNAseq2024",
    "section": "Temario del curso",
    "text": "Temario del curso\n\nMÓDULO I: Introducción a R base\n1.1 Conceptos básicos (La consola en R y Rstudio, ejecutar, llamar, correr y devolver, objetos, constantes y variables, funciones, documentación, directorio de trabajo, sesión, paquetes y scripts).\n1.2 Tipos de datos (Numérico, entero, carácter, factor, lógico, nulo, NA).\n1.3 Operadores (Aritméticos, relacionales, lógicos y de asignación).\n1.4 Estructuras de datos (Vectores, matríces, arreglos, marcos de datos, listas y coerción).\n1.5 Subconjuntos (vectores, matrices y listas).\n1.6 Funciones básicas (getwd(), setwd(), length(), sort(), min(), max(), c(), seq(), t(), mean(), sd(), sum(), etc.).\n1.7 Importar y exportar datos.\n1.7 Instalar y cargar librerias\n1.7 Creación de proyectos en Rstudio\n\n\nMÓDULO II: Introducción a GNU/Linux\n2.1 Breve historia de GNU/Linux, conociendo la terminal.\n2.2 Comandos básicos.\n2.3 Flujos de control básicos (if-else, for, while).\n2.4 Gestionadores de paquetes.\n2.5 Instalación de paquetes y manejo de ambientes conda (conda, miniconda, homebrew).\n2.6 Acceso a servidores remotos.\n\n\nModulo IV: Análisis de datos de lecturas cortas (Illumina).\n4.1 Introducción a las tecnologías de secuenciación modernas.\n4.2 Control de calidad de datos (Tipos de datos, FastQC/MultiQC).\n4.3 Corte de secuencias (Trimmomatic, cutadapt, fastx-toolkit).\n4.4 Ensamble con genoma guiado y de novo (Trinity).\n4.5 Valoración del ensamble (Transrate, BUSCO).\n4.6 Análisis de genes expresados diferencialmente (Alineamiento de lecturas y estimación de la abundancia, análisis de genes y transcritos expresados diferencialmente: EdgeR, Visualización de resultados).\n4.7 Anotación funcional con trinotate (BLAST, Ontología de genes, análisis de enriquecimientos funcionales (GO, KEGG), Reactome, etc.\n4.8 Análisis de redes de proteínas (STRING)."
  },
  {
    "objectID": "1_control_calidad.html",
    "href": "1_control_calidad.html",
    "title": "Control de Calidad",
    "section": "",
    "text": "Moverse a la carpeta curso2022 y crear carpeta de trabajo Transcriptomica y acceder."
  },
  {
    "objectID": "1_control_calidad.html#lecturas-de-prueba",
    "href": "1_control_calidad.html#lecturas-de-prueba",
    "title": "Control de Calidad",
    "section": "Lecturas de prueba",
    "text": "Lecturas de prueba\nAntes de análizar las secuencias de nuestro estudio, vamos a ver unos ejemplos de cálidad de secuencias. Estas secuencias se obtuvieron de bases de datos publicas. Ojo: Estas lecturas solo son una submuestra de las originales, por lo que son mucho mas pequeñas.\n\nCreamos una carpeta parental llamada FASTQC_TEST y dentro de esta, generamos las carpetas secuencias, FASTQC_PRE y FASTQC_POST.\n\n\nmkdir -p fastqc_test/{secuencias,fastqc_pre,fastqc_post}\n\n\nDentro de la carpeta secuenciasvamos a crear un link simbólico de las secuencias que serán utilizadas.\n\n\n\n\n\n\n\nInfo\n\n\n\nRecuerda la sintaxis ln -s ORIGEN DESTINO\n\n\n\ncd fastqc_test/secuencias\n\n ln -s /LUSTRE/bioinformatica_data/genomica_funcional/Tripp/Curso_2022/FASTQC_test/secuencias/*.fastq ./\nls\n\n\n\n\n\n\n\nWarning\n\n\n\n\nPregunta: ¿Como sabe cuantas lecturas tiene cada archivo?\n\nPodemos utilizar la función grep para buscar un caracter en común de todas las lecturas y hacer pipe para contar el número de lineas que tienen ese caracter\nPor ejemplo: las lectutas SRR7096024_1.fastq, podemos utilizar el ID @SRR7096024_1\n\ncat SRR7096024_1.fastq | grep \"^@SRR70\" | wc -l\n\n\n\n\n:::info Manejador de tareas SLURM\nDentro del curso, muchos de los procesos que se correrar son muy demantantes en cuanto a poder computacional, por lo que para evitar que el cluster colapse, se utiliza un manejador de tareas el cual nos asigna los recursos necesarios cuando haya disponibilidad.\nEn el curso utilizaremos el manejador de tareas de dos formas:\n\nUtilizando archivos ejecutables (slrm) Estos archivos continenen todas las instrucciones para poder correr un programa tal como el nombre de la cola, la cantidad de memoria y numero de nucleos que se requiere asi como los nombres del output. Un ejemplo del formato de estos archivos es:\n\n\n#!/bin/bash \n#SBATCH -p cicese\n#SBATCH --job-name=fastqc\n#SBATCH --output=fastqc-%j.log\n#SBATCH --error=fastqc-%j.err\n#SBATCH -N 1\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n\n#Resto de las instrucciones\n\n\nUtilizando el script accesa-nodo el cual te asignara un nodo durante el tiempo que estemos trabajando. Es importante que cada que termines la sesión te desconectes del nodo (exit) ya que seguiras ocupando espacio aún si no estas haciendo nada\n\n::: —\n\nPosteriormente ejecutamos FASTQC. Para esto nos vamos a colocar en la carpeta fastqc_pre y generamos el siguiente slrm\n\n\n#!/bin/bash\n#SBATCH -p cicese\n#SBATCH --job-name=fastqc\n#SBATCH --output=fastqc-%j.log\n#SBATCH --error=fastqc-%j.err\n#SBATCH -N 1\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n\n\n# Exportar la ruta de FastQC_v0.11.7\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/FastQC_v0.11.7\n\nfastqc ../secuencias/*.fastq -t 8 -o ./\n\n\nDescargamos los reportes HTML generados a nuestra computadora en la carpeta de trabajo para revisarlo. Para esto, abrimos una nueva ventana de la terminal y vamos a generar una carpeta llamada FASTQC_TEST\n\n\n$LAPTOP-NNNNN:$mkdir -p FASTQC_TEST/{FASTQC_PRE,FASTQC_POST}\n\ncd FASTQC_TEST/FASTQC_PRE\n\n\n\n\n\n\n\nInfo\n\n\n\nRecuerda la sintaxis: $scp curso##@omica:ruta/de/la/carpeta/*.html ./\n\n\n\nRevisión individual de archivos .html en navegador firefox o en el navegador que tengan instalado, para verificar la calidad de las lecturas de secuenciación.\n\nfirefox SRR10858532_1_fastqc.html\nfirefox SRR10858532_2_fastqc.html\n\n:bulb: NOTA: Si estas utilizando ubuntu app, dentro de la carpeta de trabajo ejecuta\n$explorer.exe SRR10858532_1_fastqc.html\n\n\nRevisa cada uno de los reportes y discute cuales son las diferencias entre la calidad de las lecturas"
  },
  {
    "objectID": "1_control_calidad.html#limpieza-y-control-de-calidad-de-las-lecturas",
    "href": "1_control_calidad.html#limpieza-y-control-de-calidad-de-las-lecturas",
    "title": "Control de Calidad",
    "section": "2. Limpieza y control de calidad de las lecturas",
    "text": "2. Limpieza y control de calidad de las lecturas\nAhora utilizaremos el Programa Trimmomatic para cortar y filtrar las lecturas con baja calidad asi como eliminar adaptadores que puderan haber permanecido en la lecturas\n\nDentro de tu carpeta de fastqc_test en OMICA, crear la carpeta Trimmomatic en la carpeta Transcriptomica y acceder a ella.\n\nCrear la carpeta TRIMMOMATIC en la carpeta Transcriptomica y acceder a ella.\n\ncd ..\nmkdir trimmomatic\ncd trimmomatic\n\n\nGenerar el script al cual llamaremos 2.trimmomatic.slrm\n\n\nnano 2.trimmomatic.slrm\n\nEl slrm debe contener lo siguiente:\n\n#!/bin/bash\n#########################################################\n#TRIMOMMATIC\n\n## Directivas\n#SBATCH --job-name=qtrim\n#SBATCH --output=trimmomatic-%j.log\n#SBATCH --error=trimmomatic-%j.err\n#SBATCH -N 1\n#SBATCH --mem=20GB\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n#SBATCH -p cicese\n\n\n# Ruta a TRIMMOMATIC\nTRIMMOMATIC=/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trimmomatic-0.36\n\n#Ruta al archivo con los adaptadores\ntrueseq=\"$TRIMMOMATIC/adapters/TruSeq3-PE-2.fa\"\n\n\n\ncd ${SLURM_SUBMIT_DIR}\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../secuencias/SRR7096024_1.fastq ../secuencias/SRR7096024_2.fastq -baseout trimmed_SRR7096024.fastq \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../secuencias/SRR10858532_1.fastq ../secuencias/SRR10858532_2.fastq -baseout trimmed_SRR10858532.fastq \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../secuencias/rv06m_S8_L001_subset_1.fastq ../secuencias/rv06m_S8_L001_subset_2.fastq -baseout trimmed_rv06m_S8_L001.fastq \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\n\nexit 0\n\n\nCorrer el script trimmomatic.slrm\n\n\nsbatch 2.trimmomatic.slrm\nsqueue\n\n\nGenerar dos carpetas para colocar las lecturas Paired y las Unpaired. Posteriormente, mueve todas las lecturas a sus respectivas carpetas usando el comando mv\n\n\nmkdir TRIMM_U TRIMM_P\n\nmv *P.fastq TRIMM_P/\nmv *U.fastq TRIMM_U/\n\n\nAhora evalua la calidad de estas lecturas limpias con FastQC dentro de la carpeta FASTQC_TEST/FASTQC_POST. Para esto, puedes generar un nuevo archivo slrm para usar FastQC\n\n\n#!/bin/bash\n#SBATCH -p cicese\n#SBATCH --job-name=fastqc\n#SBATCH --output=fastqc-%j.log\n#SBATCH --error=fastqc-%j.err\n#SBATCH -N 1\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n\n\n# Exportar la ruta de FastQC_v0.11.7\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/FastQC_v0.11.7\n\n\nfastqc ../trimmomatic/TRIMM_P/*.fastq -t 8 -o ./\n\n\nFinalmente, transfiere los reportes nuevos a tu computadora para revisarlos\nAhora vamos a repetir los pasos del 3 al 7 pero con la misma muestra pero usando parametros mas riguroso:\nGenerar el script al cual llamaremos trimmomatic_rig.slrm\n\n\nnano run_trimmomatic_rig.slrm\n\nEl slrm debe contener lo siguiente:\n\n#!/bin/sh\n\n###Directivas\n\n#SBATCH -p cicese\n#SBATCH --job-name=trimmomatic\n#SBATCH --output=trimmomatic-%j.log\n#SBATCH --error=trimmomatic-%j.err\n#SBATCH -N 1\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 06-00:00:00\n\n\nTRIM=/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trimmomatic-0.36\n\ncd ${SLURM_SUBMIT_DIR}\n\njava -jar $TRIM/trimmomatic-0.36.jar PE ../SRR7096024_1.fastq ../SRR7096024_2.fastq -baseout trimmed_rig_SRR7096024.fastq \\\nILLUMINACLIP:TruSeq3-PE-2.fa:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:20 MINLEN:36 HEADCROP:5\n\nexit 0\n\nTransfiere los archivos a tu computadora para visualizarlos. Discute los principales cambios\n\nFinalmente, corre los pasos del 3 al 7 incluyendo todas las muestras."
  },
  {
    "objectID": "1_control_calidad.html#análisis-de-calidad-de-las-lecturas-con-fastqc-y-multiqc",
    "href": "1_control_calidad.html#análisis-de-calidad-de-las-lecturas-con-fastqc-y-multiqc",
    "title": "Control de Calidad",
    "section": "2.1 Análisis de calidad de las lecturas con FastQC y MultiQC",
    "text": "2.1 Análisis de calidad de las lecturas con FastQC y MultiQC\n\nFASTQC\nEn la carpeta de transcriptomica, crear carpeta FASTQC y con las subcarpetas FASTQC_PRE y FASTQC_POST. Acceder a carpeta FASTQC_PRE ::: {.cell}\ncd ..\nmkdir -p FASTQC/{FASTQC_PRE,FASTQC_POST}\ncd FASTQC/FASTQC_PRE/\n::: Realizar análisis de calidad de las secuencias con el programa FastQC. Se obtendrán N archivos .html y fastqc.zip . Sintaxis fastqc [-t # ] [path to file] [-o output dir]\n\n\n\n\n\n\nWarning\n\n\n\nNOTA: Para realizar este paso es posible utilizar el script accesa-nodo para solicitar un nodo en el cluster sin necesidad de hacer un archivo slurm\n\n\n\nfastqc -t 8 ../../RAW_READS/*.fastq.gz -o ./    \n\n\nls      \n\nA continuación, vamos a importar los archivos .html a nuestra PC. Para ello sigan las instrucciones siguientes:\nPaso 1. Abrir una nueva terminal para Paso 2. Acceder a nuestra carpeta de transcrptomica ::: {.cell}\n$ cd Documentos/curso2022/transrciptomica\n::: Paso 3. Crear en transcriptomica un directorio con el nombre FASTQC y dentro de él, dos que se llamen FASTQC_PRE y FASTQC_POST. ::: {.cell}\n$ mkdir -p FASTQC/{FASTQC_PRE,FASTQC_POST}\n::: Paso 4. Acceder al directorio FASTQC_PRE ::: {.cell}\n$ cd FASTQC_PRE\n::: Paso 5. Copiar dentro de este directorio todos los archivos .html que generamos en el cluster. ::: {.cell}\n$ scp curso01@omica:/home/curso01/curso2022/trascriptomica/FASTQC/FASTQC_PRE/*.html ./\n::: Paso 6. Revisión individual de archivos .html en navegador firefox o en el navegador que tengan instalado, para verificar la calidad de las lecturas de secuenciación. ::: {.cell}\n$ firefox Ctrl_rep1_500k_R1_fastqc.html \n:::\n\n\n\n\n\n\nInfo\n\n\n\n:bulb: Si estas trabajando con Ubuntu app, puedes buscar directamente los archivos en la carpeta, pero si deseas abrir chrome directamente de la terminal ejecuta la siguiente linea:\n\nexport chrome=“/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe”\n\n\n\n\nMULTIQC\nSi se quiere hacer una comparación entre todos los valores de calidad de las secuencias, se puede utilizar el programa MultiQC que utiliza los archivos generados por FastQC. Se requiere un ambiente para el programa que está basado en python 2.7\n\n\n\n\n\n\nWarning\n\n\n\nPara poder utilizar MultiQC es necesario cargar el modulo de python 2.7 y posteriormente activar el ambiente donde esta MultiQC\n\n# Para cargar el ambiente conda\n$ module load python-2.7-anaconda       \n\n# Activar ambiente\n$ source activate multiqc_py2.7                 \n\n# Para desactivar ambiente:\n$ source deactivate multiqc_py2.7                   \n\n\n\nDentro de la carpeta de FASTQ_PRE crear una carpeta llamada MULTIQC. Entramos a esta carpeta y corremos MultiQC activando el ambiente multiqc_py2.7. Se generaran las carpetas multiqc_data, multiqc_plots y multiqc_reports.html. Revisar archivo .html. Al finalizar desactivar el ambiente multiqc_py2.7. ::: {.cell}\n$ mkdir MULTIQC\n$ cd MULTIQC/\n$ multiqc ../*.zip -o ./ --data-format tsv --export --title \"Analisis pre trimming\"\n::: ::: {.cell}\n$ source deactivate multiqc_py2.7\n::: Revisar el archivo .html obtenido con MultiQC dentro de la carpeta PRE y descargarlo a su computadora personal siguiendo los pasos descritos anteriormente\n\ncd Documentos/curso2022/transrciptomica/FASTQC_PRE\nmkdir Multiqc\ncd Multiqc\nscp curso01@omica:/home/curso01/curso2022/trascriptomica/FASTQC/FASTQC_PRE/Multiqc/multiqc_report.html ./\n\n3. Revisar el archivo .hmtl obtenido con el programa MultiQC ::: {.cell}\nfirefox multiqc_report.html\n::: 4. Cerrar esta terminal en cuanto se termine de revisar el archivo .html"
  },
  {
    "objectID": "1_control_calidad.html#limpieza-y-eliminación-de-lecturas-de-mala-calidad-con-trimmomatic",
    "href": "1_control_calidad.html#limpieza-y-eliminación-de-lecturas-de-mala-calidad-con-trimmomatic",
    "title": "Control de Calidad",
    "section": "2.2. Limpieza y eliminación de lecturas de mala calidad con Trimmomatic",
    "text": "2.2. Limpieza y eliminación de lecturas de mala calidad con Trimmomatic\n\n\n\n\n\n\nWarning\n\n\n\nComo utilizaremos trimmomatic con un archivo slurm en este punto debes salir del nodo\n\n\nEn este paso se usará el programa Trimmomatic, para eliminar las secuencias de mala calidad, así como índices o adaptadores de secuenciación que pudieran haber quedado.\nCrear la carpeta TRIMMOMATIC en la carpeta transcriptomica y acceder a ella.\n\ncd ../../\nmkdir TRIMMOMATIC\ncd TRIMMOMATIC\n\nGenerar el script al cual llamaremos trimmomatic.slrm\n\nnano trimmomatic.slrm\n\nEl slrm debe contener lo siguiente:\n\n#!/bin/bash\n#########################################################\n#TRIMOMMATIC\n\n## Directivas\n#SBATCH --job-name=qtrim\n#SBATCH --output=trimmomatic-%j.log\n#SBATCH --error=trimmomatic-%j.err\n#SBATCH -N 1\n#SBATCH --mem=20GB\n#SBATCH --ntasks-per-node=8\n#SBATCH -t 6-00:00:00\n#SBATCH -p cicese\n\n\n# Ruta a TRIMMOMATIC\nTRIMMOMATIC=/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trimmomatic-0.36\n\n#Ruta al archivo con los adaptadores\ntrueseq=\"$TRIMMOMATIC/adapters/TruSeq3-PE-2.fa\"\n\n\ncd ${SLURM_SUBMIT_DIR}\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/Ctrl_rep1_500k_R1.fastq.gz ../RAW_READS/Ctrl_rep1_500k_R2.fastq.gz -baseout Ctrl_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/Ctrl_rep2_500k_R1.fastq.gz ../RAW_READS/Ctrl_rep2_500k_R2.fastq.gz -baseout Ctrl_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T1_rep1_500k_R1.fastq.gz ../RAW_READS/T1_rep1_500k_R2.fastq.gz -baseout T1_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T1_rep2_500k_R1.fastq.gz ../RAW_READS/T1_rep2_500k_R2.fastq.gz -baseout T1_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T2_rep1_500k_R1.fastq.gz ../RAW_READS/T2_rep1_500k_R2.fastq.gz -baseout T2_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T2_rep2_500k_R1.fastq.gz ../RAW_READS/T2_rep2_500k_R2.fastq.gz -baseout T2_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T3_rep1_500k_R1.fastq.gz ../RAW_READS/T3_rep1_500k_R2.fastq.gz -baseout T3_rep1.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\njava -jar $TRIMMOMATIC/trimmomatic-0.36.jar PE ../RAW_READS/T3_rep2_500k_R1.fastq.gz ../RAW_READS/T3_rep2_500k_R2.fastq.gz -baseout T3_rep2.fastq.gz \\\nILLUMINACLIP:$trueseq:2:30:10:8:true LEADING:5 TRAILING:5 SLIDINGWINDOW:4:15 MINLEN:36\n\nexit 0\n\nCorrer el script trimmomatic.slrm\n\nsbatch trimmomatic.slrm\nsqueue\n\nCrear carpetas TRIM_P y TRIM_U y mover los archivos que correspondan a cada carpeta.\n\nls \nmkdir TRIM_P TRIM_U\nmv *U.fastq.gz TRIM_U/\nmv *P.fastq.gz TRIM_P/\nls \nls TRIM_P/\n\nAhora se recomienda revisar las secuencias pareadas con FastQC y MultiQC como se realizó en los pasos anteriores. Para ello deben moverse a la carpeta FASTQC_POST para correr el script.\n\ncd ../FASTQC/FASTQC_POST/\nfastqc -t 8 ../../TRIMMOMATIC/TRIM_P/*.fastq.gz -o ./               \nls \n\nCorrer el script de MultiQC en la carpeta respectiva y checar archivo .html\n\ncd ../../MULTIQC/POST\nsource activate multiqc_py2.7\nmultiqc ../../FASTQC/FASTQC_POST/*.zip -o ./ --data-format json --export\n\n\nsource deactivate multiqc_py2.7\n\nRevisar el archivo .html obtenido con MultiQC dentro de la carpeta POST.\nCerrar esta terminal en cuanto se termine de revisar el archivo .html\n\nEn caso de haber problemas con las rutas de los programas, se puede generar un bash_profile con las rutas de todos los programas:\nPegar en el .bash_profile los paths de los programas que serán utilizados durante el curso.\n\nnano .bash_profile\n\nPegar los siguientes path de los programas que serán utilizados durante el análisis transcriptómico.\n\n# Software for transcriptomic analysis\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/FastQC_v0.11.7\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trimmomatic-0.36\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/util\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/Analysis/DifferentialExpression\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/trinity-plugins/parafly-code/bin\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/trinityrnaseq-2.4.0/trinity-plugins/parafly/bin\nexport R_LIBRARY_PATH=/LUSTRE/apps/R-3.3.1/lib64/R/library\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/ncbi-blast-2.4.0+/bin\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/TransDecoder-3.0.1\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/RNA/ricardo/bioinformatics/transdecoder\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/signalp-4.1\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/tmhmm-2.0c/bin\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/Trinotate/util/rnammer_support\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/rnammer\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/hmmer-3.1b2-linux-intel-x86_64/binaries\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/Trinotate/PerlLib\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/Trinotate/auto\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/samtools-1.7/bin\nexport PATH=$PATH:/LUSTRE/apps/bioinformatica/bowtie2\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/bin/RSEM\nexport PATH=$PATH:/LUSTRE/bioinformatica_data/genomica_funcional/Laura/bin/transrate-1.0.3-linux-x86_64/transrate\n\nActualizar el archivo .bash_profile\n\nsource .bash_profile"
  },
  {
    "objectID": "walkthrough.html",
    "href": "walkthrough.html",
    "title": "Hello, Quarto",
    "section": "",
    "text": "Markdown is an easy to read and write text format:\n\nIt’s plain text so works well with version control\nIt can be rendered into HTML, PDF, and more\nLearn more at: https://quarto.org/docs/authoring/"
  },
  {
    "objectID": "walkthrough.html#code-cell",
    "href": "walkthrough.html#code-cell",
    "title": "Hello, Quarto",
    "section": "Code Cell",
    "text": "Code Cell\nHere is a Python code cell:\n\nimport os\nos.cpu_count()\n\n8"
  },
  {
    "objectID": "walkthrough.html#equation",
    "href": "walkthrough.html#equation",
    "title": "Hello, Quarto",
    "section": "Equation",
    "text": "Equation\nUse LaTeX to write equations:\n\\[\n\\chi' = \\sum_{i=1}^n k_i s_i^2\n\\]"
  },
  {
    "objectID": "apoyo.html",
    "href": "apoyo.html",
    "title": "Recursos de apoyo",
    "section": "",
    "text": "Manuales\n\nTrinity RNAseq wiki - Sitio de Trinity\nTrinotate - Sitio de Trinotate\nFastQC - Sitio de Fastqc\nTrimmomatic - Manual de Trimmomatic\n\nLibros en línea\n\nR para Ciencia de Datos - Versión en español de conocido libro R fo Data Science de Wickham y Grolemund\nThe Big Book of R - Extensa colección de libros y materiales en línea\n\nRecursos adicionales\n\nIntroduction to bioinformatics for RNA sequence analysis - Tutorial en línea del Laboratorio Grifftih\n\nBibliografia\n\n\nAkalin, A. 2020. Computational Genomics with R.\nAltschul, S.F., Gish, W., Miller, W., Myres, E.W., Lipman, D.J., 1990. Basic local alignment search tool. J. Mol. Biol. 215, 403–410.\nBray, N. L., Pimentel, H., Melsted, P., Pachter, L., 2016. Near-optimal probabilistic RNA-seq quantification. Nat. Biotechnol. 34, 525–527\nBryant, D. M., Johnson, K., DiTommaso, T., Tickle, T., Couger, M. B., Payzin-Dogru, D., Lee, T.J., Leigh, N. D., Kuo, T. H., Davis, F. G., Bateman, J., Bryant, S., Guzikowski, A. R., Tsai, S. L., Coyne, S., Ye, W. W., Freeman, R. M., Jr, Peshkin, L., Tabin, C. J., Regev, A., Haas, B. J., Whited, J. L. 2017. A tissue-mapped Axolotl de novo transcriptome enables identification of limb regeneration factors. Cell Rep. 18, 762–776.\nChen, Y., McCarthy, D., Baldoni, P., et al. 2023 (last revised). edgeR: differential analysis of sequence read count data.\nGrabherr, M. G., Haas, B. J., Yassour, M., Levin, J. Z., Thompson, D. A., Amit, I., Adiconis, X., Fan, L., Raychowdhury, R., Zeng, Q., Chen, Z., Mauceli, E., Hacohen, N., Gnirke, A., Rhind, N., Di-Palma, F., Birren, B.W., Nusbaum, C., Lindblad-Toh, K., Friedman, N., Regev, A. 2011. Full-length transcriptome assembly from RNA-Seq data without a reference genome. Nat. Biotechnol. 29, 644–652.\nKorpelainen, E., Tuimala, J., Somervuo, P., Huss, M., & Wong, G. (2014). RNA-seq data analysis: a practical approach. CRC press.\nNewham, C., Rosenblatt, B. 2009. Learning the bash shell. 3rd edition. O’REILLY.\nSimão, F.A., Waterhouse, R.M., Loannidis, P., Kriventseva, E.V., Zdobnov, E.M. 2015. BUSCO: assessing genome assembly and annotation completeness with single copy orthologs. Bioinformatics. 31, 3210–3212.\nSmith-Unna, R., Boursnell, C., Patro, R., Hibberd, J., Kelly, S. 2016. TransRate: reference free quality assessment of de novo transcriptome assemblies. Genome Res. 26(8), 1134–1144.\nYoung, M. D., Wakefield, M. J., Smyth, G. K., Oshlack, A. 2010. Gene ontology analysis for RNA-seq: accounting for selection bias. Genome Biol. 11, R14."
  },
  {
    "objectID": "2_unix.html#sistema-operativo-gnu-linux",
    "href": "2_unix.html#sistema-operativo-gnu-linux",
    "title": "Introduccion Bash",
    "section": "1.1 Sistema operativo GNU-Linux",
    "text": "1.1 Sistema operativo GNU-Linux\n\nGNU-Linux no es UNIX.\nUNIX No es gratuito y fue desarrollado en los laboratorios Bell de AT&T por Dennis Ritchie, Ken Thompson y Douglas Mclroy.\nGNU es gratuito.\nGNU es de código abierto.\nFue inicialmente desarrollado por Richard Stallman y con el kernel-nucleo de Linus Torvalds, de ahí el nombre.\n\nLinus Torvalds \nAlgunas distribuciones GNU/Linux: \nNosotros tenemos Ubuntu (generalmente) en nuestras computadoras y el escritorio luce en su versión más simple más o menos así:\n\n¿Cómo luce la terminal?, la cuál es más poderosa y es la que estaremos usando (En el modo por defecto, el fondo es negro)"
  },
  {
    "objectID": "2_unix.html#que-es-la-shell-bash-",
    "href": "2_unix.html#que-es-la-shell-bash-",
    "title": "Introduccion Bash",
    "section": "1.2. ¿Que es la Shell? –Bash-",
    "text": "1.2. ¿Que es la Shell? –Bash-\n\nLínea de comandos = shell.\nEl nombre «bash» viene del acrónimo «Bourne Again Shell» (llamado así por su inventor Steven Bourne).\nEste fue creado para ser usado en GNU, sustituyendo a su antecesor Bourne shell de UNIX, este último es conocido en el sistema como sh.\nSh, csh, ksh y bash -> Bourne, C, Korn y Bash.\nLa –shell- es un programa que toma comandos ingresados y los procesa para que el sistema operativo sea capaz de realizar las instrucciones.\n\n\n\nbash es amigable.\nLas teclas  nos permiten accesar al historial de comandos.\nLa tecla “tabulador” [TAB] nos permite autocomplementar los nombres de los archivos y/o comandos.\nLas flechas nos permiten desplazarnos a lo largo de la línea de comandos.\n\nLlaves de control más últiles: * Ctrl + c para deterner el comando en curso. * Ctrl + d para cerrar la terminal en turno. * Ctrl + f como alternativa para desplazarnos a la derecha de la línea. * Ctrl + b para desplazarnos a la izquierda de la línea. * Ctrl + r para buscar a través del historial de comandos. * Ctrl + shiff + t para abrir nueva pestaña de terminal.\nEl ícono para abrir la Terminal debe estar en la barra izquierda de sus escritorios. Están buscando algo que se ve así:\n\n¿Qué vemos cuando abrimos la terminal?\n <—- en mi caso\nNormalmente:\n\n\nlaulogan: Indica el usuario conectado a la terminal.\n**@**: significa “en”.\nlaulogan-Inspiron-5558: Indica el nombre de la computadora a la cual estamos conectados (hostName).\n~: Indica la ruta/directorio en la cual nos encontramos, en este caso mi ruta de inicio predeterminada. Alias para user/home/\n$: Indicador para comenzar a escribir nuevas órdenes o comandos. Éste último también indica nuestro estatus dentro del sistema, es decir, si somos usuarios($) o superusuarios(#).\n\nSuper usuario (No teclear)"
  },
  {
    "objectID": "2_unix.html#estructura-de-directorios-en-gnulinux",
    "href": "2_unix.html#estructura-de-directorios-en-gnulinux",
    "title": "Introduccion Bash",
    "section": "1.3. Estructura de directorios en GNU/LINUX",
    "text": "1.3. Estructura de directorios en GNU/LINUX\nLo primero que debemos saber es cómo están estructurados los archivos en GNU-Linux.\n\n\nLa base de todo es el directorio raiz, que se representa sencillamente con /. Todos los demás directorios o carpetas tienen que estar ligados a la raiz.\nUna computadora con GNU-Linux puede tener muchos usuarios, los cuales tienen carpetas personales dentro de su carpeta home.\nPor lo general los usuarios pueden hacer cualquier cosa dentro de su home, pero no pueden borrar o modificar cosas que esten afuera.\n\nAhora vamos a darle ordenes a la terminal: Primero, ¿Cómo saber que shell estoy usando? ¡Recuerden no teclear el $!\n$ echo $SHELL o echo $0\n/bin/bash\n¿Cómo seleccionamos una shell en particular?\n$ bash"
  },
  {
    "objectID": "2_unix.html#comandos-que-dan-información-del-sistema",
    "href": "2_unix.html#comandos-que-dan-información-del-sistema",
    "title": "Introduccion Bash",
    "section": "2.1 Comandos que dan información del sistema:",
    "text": "2.1 Comandos que dan información del sistema:\narch: Muestra la arquitectura de la máquina.\n$ arch\nx86_64\nuname: Muestra la información del nucleo.\n$ uname\nLinux\ntop: Muestra los procesos que están siendo ejecutados. Para salir teclear q.\n$ top\nTareas: 291 total,   1 ejecutar,  290 hibernar,    0 detener,    0 zombie\n%Cpu(s):  1.2 usuario,  0.5 sist,  0.0 adecuado, 97.8 inact,  0.4 en espera,  0.0 hardw int,  0.0 softw int,  0.0 robar tiempo\nKiB Mem : 16320116 total,  7871832 free,  5008656 used,  3439628 buff/cache\nKiB Swap:  4081660 total,  4081660 free,        0 used. 10551424 avail Mem \n\n  PID USUARIO   PR  NI    VIRT    RES    SHR S  %CPU %MEM     HORA+ ORDEN                                                                      \n 3063 pavel     20   0  796284  57556  35788 S   1.7  0.4   2:37.23 python                                                                     \n 8599 pavel     20   0  796284  57592  35828 S   1.3  0.4   0:20.73 python                                                                     \n 3016 pavel     20   0 3793164 558636 213724 S   1.0  3.4  10:41.32 firefox-bin                                                                \n 4323 pavel     20   0 3528284 641308 132312 S   0.7  3.9   3:17.20 Web Content                                                                \n 9685 pavel     20   0   44540   3816   3088 R   0.7  0.0   0:00.04 top   \nhistory: Con el podemos ver el historial de los comandos ingresados.\n$ history\n1955  ls\n 1956  wc -l Glandula_oviducalPOSvsLO_GO.all_genes_gene_level.txt_down_upgenes.txt_add_annotation.txt Glandula_oviducalPOSvsLO_GO.down_genes_gene_level.txt\n 1957  cd ..\n 1958  ls\n 1959  cd ..\n 1960  ls\n 1961  cd lobulo_optico/\n 1962  ls\n 1963  cd pre-desove/\n 1964  ls\n 1965  ./2.get_gene_names.pl Lobulo_OpticoPREvsGO_GOV.all_genes_gene_level.txt_just_upgenes.txt\nman: Muestra el manual de uso de un comando. Para salir teclear q.\n$ man cat\nCAT(1)                                                         User Commands                                                         CAT(1)\n\nNAME\n       cat - concatenate files and print on the standard output\n\nSYNOPSIS\n       cat [OPTION]... [FILE]...\n\nDESCRIPTION\n       Concatenate FILE(s) to standard output.\n\n       With no FILE, or when FILE is -, read standard input.\n\n       -A, --show-all\n              equivalent to -vET\n\n       -b, --number-nonblank\n              number nonempty output lines, overrides -n\n¿Cómo podemos búscar comandos relacionados con cierta función pero que desconocemos su nombre?. Por ejemplo si quisieramos encontrar el comando que nos da la fecha, ¿Cómo le hacemos?\n$ man -k \"palabra clave\"\n$ man -k \"date\"\n../..\n\ndate (1)             - print or set the system date and time\n\n../..\n$ apropos \"palabra clave\"\n$ apropos date\n../..\ndate (1)             - print or set the system date and time\n../..\n\nexit: Cierra la terminal en uso.\n$ exit\nAhora, ¿Cómo podemos acceder a todas las opciones que te da un comando?\nuname --help\nModo de empleo: uname [OPCIÓN]...\nMuestra cierta información del sistema. Sin ninguna OPCIÓN, igual que -s.\n\n  -a, --all            muestra toda la información, en el siguiente orden,\n                         excepto que se omite -p y -i si son desconocidos:\n  -s, --kernel-name    muestra el nombre del núcleo\n  -n, --nodename       muestra el nombre de `host' del nodo de red\n  -r, --kernel-release muestra la versión del núcleo\n  -v, --kernel-version     print the kernel version\n  -m, --machine            print the machine hardware name\n  -p, --processor          print the processor type (non-portable)\n  -i, --hardware-platform  print the hardware platform (non-portable)\n  -o, --operating-system   print the operating system\n      --help     muestra esta ayuda y finaliza\n      --version  informa de la versión y finaliza\n\nayuda en línea sobre GNU coreutils: <http://www.gnu.org/software/coreutils/>\nInforme de errores de traducción en uname a <http://translationproject.org/team/es.html>\nFull documentation at: <http://www.gnu.org/software/coreutils/uname>\nor available locally via: info '(coreutils) uname invocation'\nEn otros comandos se puede obtener lo mismo usando la bandera: -h, como mencioné anteriormente."
  },
  {
    "objectID": "2_unix.html#comandos-para-manipular-archivos-y-directorios.",
    "href": "2_unix.html#comandos-para-manipular-archivos-y-directorios.",
    "title": "Introduccion Bash",
    "section": "2.2 Comandos para manipular archivos y directorios.",
    "text": "2.2 Comandos para manipular archivos y directorios.\nPara saber en qué lugar-path se encuentran al abrir la terminal:\npwd: de print work directory, te da la ruta actúal donde te encuentras.\n$pwd\n/home/pavel\ncd: de change directory, te permite cambiar de directorios. / accedemos a la raíz del sistema; ~ accedemos al directorio por defecto home/usuario; ../ accedemos al directorio padre, es decir, retrocedemos de nivel. cd - regresamos a donde estabamos.\nPara prácticar vamos a crear dos directorios con el siguiente comando:\nmkdir: Permite crear directorios.\n$ cd #para posicionarnos en /home/user; donde user es su nombre de usuario, en mi caso \"pavel\"\n$ mkdir proyecto #creamos el directorio.\nAhora con el comando cd nos movemos a ese directorio:\n$ cd proyecto\nSi ingresan el comando pwd podrán ver que ahora su posición ha cambiado. Ahora creen en “proyecto” un directorio llamado genoma, y se regresan a su home/usuario\n\nUsando {} como expasión de llaves:\n$ mkdir -p proyecto/{secuencias/rnaseq,blast}\nls: Muestra el contenido de un directorio. -la lista el directorio en formato lista y además muestra todos los archivos ocultos; -h muestra los tamaños del fichero en formato legible; -t acomoda la lista por fecha.\n$ ls -ls\n$ ls -la\n$ ls -lth\n\nPermisos:\n\nchmod: Comando para cambiar permisos.\n$ chmod u+x file\n$ chmod uga+x file\n$ chmod uga-x file\ntouch [filename]: crea archivos vacíos con el nombre especificado.\nvayamonos a cd ~ o solo cd\n$ touch seq.fq\nUsando las llaves podemos generar una seríe de archivos como:\n$ touch seq.fq{1..10}\nseq.fq1  seq.fq10  seq.fq2  seq.fq3  seq.fq4  seq.fq5  seq.fq6  seq.fq7  seq.fq8  seq.fq9\ncp [origen] [destino]: copia archivos de un directorio a otro. También podemos hacer una copia de un archivo y renombrarlo.\n$ cp seq.fq1 copia_seq.fq1\n$ cp seq.* /proyecto/genoma\n$ rm seq.*\n¿Cómo copiar de un directorio a nuestra posición actúal?\n$ cp /proyecto/genoma/seq.* .\n¿Qué pasó?\n-Comodines * (wildcards)\nmv [origen] [destino]: sirve para mover archivos o para renombrar archivos y directorios.\npara renombrar archivos:\n$ mv seq.fq1 seq.fq300\npara mover:\n$ mv seq.fq10 proyecto/genoma/\nrm [file]: Sirve para borrar archivos. -rf borra los archivos de forma recursiva sin preguntar y no vuelven núnca más. rmdir elimina directorios.\n$ rm seq.fq3\n$ rm seq.* #borra todo lo que inicia con seq. seguido de cualquier cosa, usar con cuidado.\n$ mkdir prueba \n$ rm -rf prueba"
  },
  {
    "objectID": "2_unix.html#comandos-para-descargar-comprimir-y-descomprimir-archivos.",
    "href": "2_unix.html#comandos-para-descargar-comprimir-y-descomprimir-archivos.",
    "title": "Introduccion Bash",
    "section": "2.3 Comandos para descargar, comprimir y descomprimir archivos.",
    "text": "2.3 Comandos para descargar, comprimir y descomprimir archivos.\nwget: Se usa para descargar archivos del internet via TTP, HTTPS, FTP, o FTPS. wget [OPTIONS]… [ URLS ]\nvamos a descargar el genoma del virus de la influenza:\n$ wget  ftp://ftp.ncbi.nlm.nih.gov/genomes/INFLUENZA/influenza.faa.gz\nOtro comando similar es curl: Este es más poderoso que wget y acepta más protocolos.\nPara descargar el mismo archivo usariamos el siguiente comando:\ncurl -O ftp://ftp.ncbi.nlm.nih.gov/genomes/INFLUENZA/influenza.faa.gz\ngzip: por GNU zip, esta es una herramienta para comprimir archivos usando la línea de comandos de GNU. Los archivos que son comprimidos usando esta herramienta usualmente contienen la extensión .gz. Para descomprimir usamos gunzip.\nVamos a descomprimir el archivo que recien descargamos.\n$ cd proyecto # nos vamos a la carpeta proyecto\n$ gunzip influenza.faa.gz # descomprir en la carpta proyecto el archivo\nbzip2: Es similar a gzip, pero están construidos bajo diferentes algoritmos.\nbzip2 influenza.faa\nbunzip2 influenza.faa.gz\nLos que quieran saber más sobre el rendiemiento de ambas: https://www.rootusers.com/gzip-vs-bzip2-vs-xz-performance-comparison/\ntar: tar es un programa usado para crear y manipular archivos. tar une varios archivos en uno solo, preservando sus nombres y demás permisos. Resulta muy adecuado cuando se desea almacenar muchos archivos relacionados para que sean transferidos por la red, asi como cuando se hacen respaldos de discos completos y resulta muy práctico para su transporte en diferentes sistemas.\nPara generar un archivo tar de varios usamos el siguiente comando:\n$ touch adn.txt arn.txt\n$ tar -cvf prueba.tar adn.txt arn.txt\n$ tar -xf prueba.tar\n$ tar -cvzf prueba.tar.gz adn.txt arn.txt #empaquetar y comprimir\n$ tar -xzf prueba.tar.gz #desempaquetar y descomprimir\n$ tar -cjvf prueba_2.tar.bz2 adn.txt arn.txt\n$ tar -xjf prueba_2.tar.bz2\n-c: crea un nuevo archivo. -v: verbose, muestra una salida. -z: compresión con gzip. -j: compresión con bzip2. -f: selecciona el archivo que queremos comprimir y siempre debe de ir al final de las opciones. -x: extrae documentos de un archivo tar."
  },
  {
    "objectID": "2_unix.html#comandos-para-visualizar-archivos.",
    "href": "2_unix.html#comandos-para-visualizar-archivos.",
    "title": "Introduccion Bash",
    "section": "2.4 Comandos para visualizar archivos.",
    "text": "2.4 Comandos para visualizar archivos.\nmore: Permite visualizar archivos desde el inicio. Muestra texto en una terminal. Para avanzar presionar ENTER. Para salir de la visualización presionar q. Para visulizar archivos gzip, usamos zmore.\n$ zmore influenza.faa.gz\nless: Permite de igual forma que more visualizar archivos. A diferencia de more se puede retroceder y avanzar con las flechas. Para salir, presionar q.\n$ zless influenza.faa.gz\nAhora vamos a bajarnos el siguiente archivo file.txt en: https://drive.google.com/drive/u/1/folders/14Z7wmv4suhC-DLvDo9tUTNkF8WtVPRSD\nhead: Muestra en la terminal las primeras líneas de un archivo. Para especificar el número de lineas a mostras usar la opción -n.\n$ head -n 20 file.txt\ntail: igual que head pero muestras las líneas al final del documento.\n$ tail -n20 file.txt\nwc: Muestra el número de líneas, caracteres o palabras que contiene un archivo. Opciones -l para líneas, -m para caracteres y -w para palabras.\n$ wc -lmw file.txt\n50  1838 82964 file.txt\nAntes de continuar con los demás comandos vamos a introducir el concepto de entrada y salida estandar.\n\ncat: El comando cat en bash significa “concatenar”. Este comando es usado para mostrar, crear, y agregar archivos.\n$ cat file.txt  #toma la entrada estandar y muestra la salida estandar en pantalla.\nusando el > y >> podemos redirigir la salida estandar, es decir, en lugar que nos mande la salida a la pantalla que la mande a un archivo. Esto para cualquier comando.\n$ cat file.txt > replica_file.txt\nCon este comando, siempre se sobreescribe el archivo. Si quisieramos agregar nueva información al final del archivo usamos el doble mayor >>\n$ cat file.txt >> replica_file.txt\nPara concatenar archivos:\n$ cat file.txt replica_file.txt > conca_ejem.txt\ncut: Extrae información de un archivo. Siempre se debe especificar una opción. -f (campo) más común y el tipo de delimitador -d (por defecto tabulador)\n$ cut -f1 file.txt > first_col.txt\n#gene_id\nTRINITY_DN10676_c0_g1\nTRINITY_DN20389_c0_g1\nTRINITY_DN20515_c0_g1\nsort: Organiza las líneas en un archivo de texto para que se ordenen de forma numérica o alfabéticamente.\n$ sort first_col.txt > first_col_sort.txt\nuniq: Elimina líneas repetidas dentro de un archivo. Sólo funciona con líneas repetidas adyacentes. Primero se deben ordenar las líneas dentro del archivo usando sort.\n$ uniq first_col_sort.txt > first_col_sort_uniq.txt\n¿Cómo podemos hacer todo esto en una sola línea de comando?, aqui es donde entender la entrada y salida estandar se vuelven útiles.\n| Este operador conocido como pipe te permite usar la salida estandar de un comando como entrada estandar de otro.\n$ cut -f1 file.txt | sort | uniq > first_col_sort_uniq_pipe.txt\nNota: Podemos extraer múltiples columnas haciendo cut -f 1,4,8 archivo\ngrep: Este comando nos permite buscar una palabra o un patrón que definamos dentro de un archivo de texto. Por ejemplo, si quisieramos buscar este identificador TRINITY_DN32673_c0_g1 en nuestro archivo de anotación.\n$ grep -i \"TRINITY_DN32673_c0_g1\" file.txt #nos muestra toda la linea de la coincidencia.\n\n$ grep -io \"TRINITY_DN32673_c0_g1\" file.txt #nos muestra solo la concidencia exacta.\n\n$ grep -ic \"^>\" influenza.faa #contar número de secuencias. \nLa opción -i es para que ignore las minusculas y mayusculas, -o para una coincidencia exacta, y la -c cuenta las líneas que tuvieron coincidencia.\nLa variante de grep que te permite buscar patrones es egrep. En este curso no entraremos a detalle. A los que les interese primero deben buscar sobre expresiones regulares. Les recomiendo este libro —> https://doc.lagout.org/operating%20system%20/linux/grep%20-%20Pocket%20Reference.pdf\nsed: Este comando nos permite buscar con texto y/o patrones y reemplazar las coincidencias.\nsed ‘s/buscar/reemplazar/g’ # La g aqui es por global y significa que haga el cambio en todas las coincidencias, no solo en la primera. Si quieren modificar en el mismo archivo usar la opción -i.\n$ sed 's/TRINITY/trinity/g' file.txt > file_sed.txt"
  },
  {
    "objectID": "2_unix.html#enlace-simbólico.",
    "href": "2_unix.html#enlace-simbólico.",
    "title": "Introduccion Bash",
    "section": "2.5 Enlace simbólico.",
    "text": "2.5 Enlace simbólico.\nUn enlace simbólico es un archivo que apunta a otro archivo (o a un directorio), estos son como los “accesos directos” en Windows. Su finalidad es la de no duplicar archivos para no usar más memoria, en especial aquellos que son de gran tamaño.\nln -s [Origen] [Destino] : Link (enlace) simbólico indica un acceso directo a una carpeta o archivo que se encuentra en un lugar distinto dentro de la estructura de directorios. Si el archivo ligado es renombrado, movido o borrado se rompe el acceso.\n$ ln -s proyecto/genoma/ . #en este caso hicimos un link al directorio genoma.\n$ rm o unlink genoma #para eliminar el enlace simbolico."
  },
  {
    "objectID": "2_unix.html#comando-para-conexión-remota",
    "href": "2_unix.html#comando-para-conexión-remota",
    "title": "Introduccion Bash",
    "section": "2.6 Comando para conexión remota",
    "text": "2.6 Comando para conexión remota\nssh: Es un programa para iniciar sesión y ejecutar comandos en una maquina remota. Proporciona comunicaciones cifradas seguras a través de una red insegura.\n$ ssh [user@]hostname\n\n2.6.1 Conexión a la red local de cicese\nPara conectarse a la red de CICESE a través de VPN deben seguir las instrucciones siguientes:\nContar con:\n\nUsuario de cuenta de correo CICESE\nContraseña original\n\nPaso 1: Instalar vpn\n$ sudo apt-get install vpnc\nPaso 2: Acceder a VPN de CICESE\n$ sudo vpnc\nPaso 3: Colocar la información requerida.\nIPSeq gateway adress: 158.97.255.193\nIPSeq ID: VPNCICESE\nIPSeq secret: c1c3s3VPN\nUsername: <usuario>\nPassword: <contraseña_original>\nTip: para no estár ingresando estos datos cada vez que queremos conectarnos a la red del cicese.\n\nIr a /etc/vpnc.conf\nAgregar la información anterior.\nListo\n\nAhora para conectarse solo escribirán:\n$ sudo vpnc #les pedirá su contraseña de sesión por usar sudo\nSi la conexión fue exitosa, verán en su pantalla algo como:\nConnect Banner:\n| Conexion VPN establecida - Bienvenido a la Red CICESE\n| \n| Por favor lea las politicas de uso del servicio de VPN disponibles en:\n| \n| http://telematica.cicese.mx\n| \n| Haga click en \"Continuar\" (o en \"OK\") para empezar a hacer uso del servicio de VPN.\n| \n| Haga click en \"Desconectar\" para cancelar esta sesion.\n| \n| Mensaje escrito sin acentos.\n| \n\nVPNC started in background (pid: 1362)...\nPara desconectarse:\n$ sudo vpnc-disconnect # recuerden pueden usar TAB para autocoplementar\n$ ps -aux | grep \"vpnc\" # en algunos casos\n$ kill IDjob # kill nos permite matar un proceso.\n\n\n2.6.2 Acceso a la supercomputadora/Cluster OMICA\nCada estudiante deberá acceder al cluster OMICA con una cuenta del curso.\n\nDirectorio base de trabajo: /LUSTRE/bioinformatica_data/curso2022\nRecordando que deben trabajar en la zona de lustre y no en sus directorios personales para lo cual deben utilizar: cd curso2022 Esta instrucción posicionará a cada estudiante en la trayectoria de su respectivo subdirectorio: /LUSTRE/bioinformatica_data/curso2022/accounts/cursoNN\nSubstituir el doble hash (##) por el número de cuenta asignado (ver tabla arriba).\n$ ssh curso##@omica\nTip: Para hacer el acceso menos laborioso seguir los siguientes pasos:\n\nIr a /home/pavel/.ssh #sustituir pavel por su nombre de usuario.\nAbrir el archivo oculto .ssh.\npegar:\n\nHost cicese HostName omica User pgalindo #poner el suyo.\nAhora para conectarse solo bastará:\n$ssh cicese #Les pedirá su contraseña de usuario.\n\n2.6.2.1 Copiar archivos de manera remota, servidor(omica)-pc. Bidireccional.\nSi quisieramos enviar un archivo a nuestro home en omica:\n$ scp file_sed.txt curso01@omica:/home/curso01/\nAhora, copiar de omica a nuestro pc:\n$ rm file_sed.txt #primero borramos el archivo file_sed.txt en nuestro ordenador\n$ scp curso01@omica:/home/curso01/file_sed.txt ."
  },
  {
    "objectID": "2_unix.html#resumen-de-comandos.",
    "href": "2_unix.html#resumen-de-comandos.",
    "title": "Introduccion Bash",
    "section": "2.7 Resumen de comandos.",
    "text": "2.7 Resumen de comandos."
  },
  {
    "objectID": "2_unix.html#hacer-nuestros-propios-comandos",
    "href": "2_unix.html#hacer-nuestros-propios-comandos",
    "title": "Introduccion Bash",
    "section": "2.8 Hacer nuestros propios comandos",
    "text": "2.8 Hacer nuestros propios comandos\nEsta herramienta resulta muy útil para acortar la escritura de instrucciones largas, por ejemplo:\n$ alias l='wc -l' # contar líneas de archivo\n$ alias pulpo='cd /media/pavel/Pavel/librerias_ml/proyecto_omaya_embriones'\n$ alias sec='cd /home/pavel/proyecto/secuencias/; ls'\nPara remover el alias teclear unalias. Para hacerlo permanente ir a home/user, abrir el archivo .bashrc y agregar la instrucción en la sección de alias. Al abrir una nueva terminal, este alias será permanente."
  },
  {
    "objectID": "2_unix.html#editor-de-texto-en-la-terminal",
    "href": "2_unix.html#editor-de-texto-en-la-terminal",
    "title": "Introduccion Bash",
    "section": "2.9 Editor de texto en la terminal",
    "text": "2.9 Editor de texto en la terminal\nnano: Es un editor de texto que es fácil de usar. Incluye todas las funcionalidades básicas que podrías esperar de un editor de textos regular.\n$ nano prueba.txt\nUna vez abierto pueden ingresar el texto que deseen. Para guardar Ctrl + O y pasa salir Ctrl + x.\n\nAcá les dejo otros editores más amigables: Sublime Text:\nLink: https://www.sublimetext.com/ \nVisual Studio Code: Link: https://code.visualstudio.com/"
  },
  {
    "objectID": "2_unix.html#gnulinux",
    "href": "2_unix.html#gnulinux",
    "title": "Introduccion Bash",
    "section": "4.1 GNU/Linux",
    "text": "4.1 GNU/Linux\nDependiento de la distribución de GNU-Linux que estemos usando vamos a emplear un comando para poder descargar, instalar y borrar software con sus respectivas dependencias. Generalmente el comando más común es: apt-get\n$ sudo apt-get update #este codigo actualiza los paquetes ya intalados. Se necesitan privilegios de super usuario.\nsudo apt-get install [Nombre del paquete] #Para instalar paquete\nsudo apt remove [Nombre del paquete] # borrar paquete o paquetes."
  },
  {
    "objectID": "2_unix.html#macos",
    "href": "2_unix.html#macos",
    "title": "Introduccion Bash",
    "section": "4.2 MacOS",
    "text": "4.2 MacOS\nHomebrew: Homebrew instala todo aquello que necesitas pero que no viene por defecto instalado (más detalle en: https://brew.sh/index_es) \nUna vez instalado pueden por ejemplo correr el siguiente comando para instalar wget:\n$ brew install wget"
  },
  {
    "objectID": "2_unix.html#ambientes-virtuales",
    "href": "2_unix.html#ambientes-virtuales",
    "title": "Introduccion Bash",
    "section": "4.3 Ambientes virtuales",
    "text": "4.3 Ambientes virtuales\n\n4.3.1 Conda:\n\nConda es un manejador de paquetes, dependencias y ambientes para cualquier lenguaje, Python, R, Ruby, Lua, etc. Conda puede correr en windows, macOS y GNU-Linux.\n\nVisiten el siguiente link para entrar más a detalle sobre los comandos para gestionar paquetes y ambientes –> https://docs.conda.io/projects/conda/en/latest/index.html"
  },
  {
    "objectID": "2_unix.html#sintaxis",
    "href": "2_unix.html#sintaxis",
    "title": "Introduccion Bash",
    "section": "5.1 Sintaxis",
    "text": "5.1 Sintaxis\n\nif/else:\nif [[ CONDICION ]]; then\n    echo \"la condición se cumplió\"\nelse\n    echo \"la condición no se cumplió\"\nfi\nMás de una condición:\nif [[ CONDICION ]]; then\n    echo \"la condición se cumplió\"\nelif [[ CONDICION 2 ]]; then\n    echo \"la condición 1 no se cumplió pero la 2 si\"\nelse\n    echo \"ninguna condición se cumplió\"\nfi\n\n\nfor:\nfor var in list\ndo\n  command1\ndone\nOtra variante:\nfor((i=1;i<=10;i+=2)); do \necho \"Welcome $i times\"; \ndone\n\n\nwhile:\nwhile [condition]\ndo\n   command-1\n   command-2\n     ...\n     ...\n   command-n\ndone"
  },
  {
    "objectID": "2_unix.html#finalmente",
    "href": "2_unix.html#finalmente",
    "title": "Introduccion Bash",
    "section": "Finalmente…",
    "text": "Finalmente…"
  },
  {
    "objectID": "2_unix.html",
    "href": "2_unix.html",
    "title": "Introduccion Bash",
    "section": "",
    "text": "code"
  },
  {
    "objectID": "1_Rbasico.html",
    "href": "1_Rbasico.html",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "",
    "text": "R es un lenguaje de programación y un entorno de software libre dedicado principalmente al análisis estadístico y la visualización de datos. Desarrollado inicialmente por los laboratorios de AT&T a pártir de otro lenguaje de programación.\nEntre las caracteristicas que han hecho de R un lenguaje muy popular entre la comunidad científica y academica (ademas de que es gratuito 😉 ) es su capacidad para manejar y analizar grandes conjuntos de datos, junto con una vasta colección de paquetes desarrollados por la comunidad, lo hace altamente versátil y poderoso.\nAdemás, R se destaca por su capacidad para crear gráficos de alta calidad y visualizaciones interactivas, lo que facilita la interpretación y comunicación de resultados complejos. La facilidad de integración con otros lenguajes y sistemas, así como su fuerte enfoque en la reproducibilidad de la investigación, han cimentado su lugar como una herramienta indispensable para científicos, estadísticos y analistas de datos en todo el mundo.\n¿Mencioné que R es gratuito?"
  },
  {
    "objectID": "1_Rbasico.html#trabajando-con-vectores",
    "href": "1_Rbasico.html#trabajando-con-vectores",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Trabajando con vectores",
    "text": "Trabajando con vectores\nUn vector es la estructura de datos más sencilla en R. Un vector es una colección de uno o más datos del mismo tipo.\nPara crear un vector utilizamos el comando c(), de combinar\n\nnumeros &lt;- c(1, 2, 3)\n\nnumeros\n\n[1] 1 2 3\n\n\nTambién podemos crear un nuevo vector a partir de otros objetos en el ambiente\n\nx\n\n[1] 2\n\ny\n\n[1] 3\n\nz\n\n[1] 5\n\nvariables &lt;- c(x, y, z)\nvariables\n\n[1] 2 3 5\n\n\nLos vectores tambien puende contener elementos de otros tipos como caracteres, los cuales tienen que ir dentro de comillas \" \".\n\nnombres &lt;- c(\"Juan\", \"Pepe\", \"Sofia\")\n\n\n\n\n\n\n\n\n\n\n\n¿Que pasa si intentamos unir el vector de caracteres (nombres) con numeros (variables)\n\nnombre_variable &lt;- c(nombres, variables)\nnombre_variable\n\n[1] \"Juan\"  \"Pepe\"  \"Sofia\" \"2\"     \"3\"     \"5\"    \n\n\nComo las cadenas de texto son el tipo de dato más flexible, siempre que creamos un vector que incluye un dato de este tipo, el resultado será un vector de texto.\n\n\nPodemos crear vectores de secuencias numéricas usando :. De un lado de los dos puntos escribimos el número de inicio de la secuencia y del otro el final.\nPor ejemplo, creamos una secuencia del 1 al 10\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\nVectorización de operaciones\nLas operaciones aritméticas y relacionales pueden vectorizarse. Si las aplicamos a un vector, la operación se realizará para cada uno de los elementos que contiene.\nPor ejemplo, podemos sumar 2 a cada uno de los elementos del vector numeros\n\nnumeros + 2\n\n[1] 3 4 5\n\n\nTambién podemos realizar operaciones relacionales (VERDADERO, FALSO) con nuestro vector. Por ejemplo, evaluar cual de nuestro elementos es mayor a 4\n\nnumeros &gt; 4\n\n[1] FALSE FALSE FALSE\n\n\nEjercicio:\nSupon que tienes un cultivo de abulones y tienes que revisarlo todos los dias y contar los organismos muertos. Despues de una semana tienes el siguiente resultado:\n\nlunes: 4\nmartes: 6\nmiercoles: 0\njueves: 10\nviernes: 12\nsabado: 8\ndomingo: 4\n\n1: crea un vector con los valores diarios 2: nombre cada valor con el dia de la semana usando la funcion names()\n\nmortalidad &lt;- c(4,6,0,10,12,8,4)\nmortalidad\n\n[1]  4  6  0 10 12  8  4\n\nnames(mortalidad) &lt;-  c(\"Lunes\", \"Martes\", \"Miercoles\", \"Jueves\", \"Viernes\", \"Sabado\", \"Domingo\")\n\nmortalidad\n\n    Lunes    Martes Miercoles    Jueves   Viernes    Sabado   Domingo \n        4         6         0        10        12         8         4 \n\n#nombrar la mortalidad con la funcion names\n\nOperaciones basicas con vectores\n\n\n\nFunción\nsignificado\n\n\n\n\nmin()\nMinimo\n\n\nmax()\nMáximo\n\n\nlength()\nlongitud\n\n\nrange()\nintervalo de valores\n\n\nsort()\nOrdena de menor a mayor\n\n\nunique()\nValores unicos\n\n\nmean()\nPromedio\n\n\nsum()\nsuma\n\n\nwhich()\nproporciona los indices TRUE\n\n\n\nEjercicio: Contesta lo siguiente:\n\n¿cual fue el valor minimo y el maximo?\n¿cuantos abulones murieron esa semana?"
  },
  {
    "objectID": "1_Rbasico.html#introducción",
    "href": "1_Rbasico.html#introducción",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "",
    "text": "R es un lenguaje de programación y un entorno de software libre dedicado principalmente al análisis estadístico y la visualización de datos. Desarrollado inicialmente por los laboratorios de AT&T a pártir de otro lenguaje de programación.\nEntre las caracteristicas que han hecho de R un lenguaje muy popular entre la comunidad científica y academica (ademas de que es gratuito 😉 ) es su capacidad para manejar y analizar grandes conjuntos de datos, junto con una vasta colección de paquetes desarrollados por la comunidad, lo hace altamente versátil y poderoso.\nAdemás, R se destaca por su capacidad para crear gráficos de alta calidad y visualizaciones interactivas, lo que facilita la interpretación y comunicación de resultados complejos. La facilidad de integración con otros lenguajes y sistemas, así como su fuerte enfoque en la reproducibilidad de la investigación, han cimentado su lugar como una herramienta indispensable para científicos, estadísticos y analistas de datos en todo el mundo.\n¿Mencioné que R es gratuito?"
  },
  {
    "objectID": "1_Rbasico.html#generalidades",
    "href": "1_Rbasico.html#generalidades",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Generalidades",
    "text": "Generalidades\nEn este primer capítulo vamos a revisar algunas funcionalidades básicas de R tales como crear objetos y vectores asi como revisar los diferentes tipos de estructuras de datos.\nAntes de empezar, es importante mencionar algunas aspectos:\n\nR es sensible a las mayúsculas y minúsculas, de manera que A es diferente que a de la misma forma que la función anova() es diferente a la función Anova()\nEl símbolo # sirve para insertar un comentario en la línea de comando, de manera que todo lo que siga después de # no se ejecutara. Es importante incluir comentarios como parte de las buenas practicas en el uso de R ya que le facilitará el trabajo a tus colaboradores y revisores saber que estas haciendo en casa paso y te salvará la vida cuando intentes correr tu script cinco años después de haberlo escrito\nEn la consola usualmente veremos el símbolo &gt; lo que la indica que la consola esta lista para recibir nuevas instrucciones. Si por el contrario vemos el símbolo + entonces nos esta indicando que no hemos terminado de completar correctamente una línea de código.\nSi despúes de ejecutar un comando la consola nos arroja un mensaje de advertencia WARNING significa que el comando se ejecutó pero hay algo inesperado que debe revisarse. Por el contrario si nos arroja un mensaje de error ERROR entonces hay algo mal en la línea de codigo y por lo tanto no se pudo ejecutar."
  },
  {
    "objectID": "1_Rbasico.html#uso-de-la-línea-de-comando-como-calculadora",
    "href": "1_Rbasico.html#uso-de-la-línea-de-comando-como-calculadora",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Uso de la línea de comando como calculadora",
    "text": "Uso de la línea de comando como calculadora\nPodemos utilizar R para realizar operaciones básicas:\n\n1 + 2 #suma\n\n[1] 3\n\n4 - 3 #resta\n\n[1] 1\n\n5 * 5 #multiplicación\n\n[1] 25\n\n4 / 2 #división\n\n[1] 2\n\n4 ^ 2 #Exponente\n\n[1] 16\n\n4 ** 2 #Exponente\n\n[1] 16\n\n\n\n\n\n\n\n\n!! ¿por qué hay un [1] en cada resultado?\n\n\n\nEl resultado es un vector, aunque solo consista en un elemento. Por lo tanto, R indica que este el primer [1] elemento de un vector\n\n\nOperadores en R:\n\n\n\nOperador\nsignificado\n\n\n\n\n*\nMultiplicación\n\n\n-\nResta\n\n\n+\nSuma\n\n\n^\nElevar a potencia\n\n\n/\nDivisión\n\n\n&lt;\nMenor que\n\n\n&gt;\nMayor que\n\n\n&lt;=\nMenor o igual que\n\n\n&gt;=\nMayor o igual que\n\n\n==\nExactamente igual\n\n\n!=\nDistinto"
  },
  {
    "objectID": "1_Rbasico.html#uso-de-objetos",
    "href": "1_Rbasico.html#uso-de-objetos",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Uso de objetos",
    "text": "Uso de objetos\nPara crear un nuevo objeto se puede usar “=” o “&lt;-”. Este nuevo objeto, se almacenará en la memoria y se puede usar para otras operaciones.\n\nx &lt;- 2 #asignar a la variable x el valor de 2\nx\n\ny = 3 #asignar a la variable y el valor de 3\ny\n\n#resultado de la suma x + y\nx + y\n\nz &lt;- x + y #asiganr el resultado de x + y  a la variable z\nz\n\nLas variables no solo puede contener números, sino caracteres, listas o incluso graficas\n\ncaracter &lt;- \"siete\"\ncaracter\n\n[1] \"siete\"\n\n\n\n\n\n\n\n\nEjercicio:\n\n\n\n\n¿cual serial el resultado de multiplicar la variable mix * 3?\n¿Cuales de estas formas de definir una variables es incorrecta?\n\n\nmi.variable &lt;-\nmi_variable &lt;-\nmi variable &lt;-\nmi-variable &lt;-"
  },
  {
    "objectID": "1_Rbasico.html#tipos-y-estructura-de-datos-classes",
    "href": "1_Rbasico.html#tipos-y-estructura-de-datos-classes",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Tipos y estructura de datos (Classes)",
    "text": "Tipos y estructura de datos (Classes)\nR tiene los siguientes tipos de datos basicos:\n\nlogical: valores lógicos, pueden ser TRUE o FALSE\nnumeric: números reales (1.0,2,3.1416, 3E-10)\ncharacter:caracteres (letras y/o números). Delimitados por “” (“uno”, “Miguel”, “FALSO”)\ninterger:valores enteros (1,2,3)\nNA: dato no disponible\nNaN:no es un número (not a number)\n\nPor otro lado, las estructuras de datos pueden ser de tipo vector, data.frame, matriz, arreglo o lista:\n\nfuente: http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png\nEs importante resaltar que solamente los data.frame pueden contener distintos tipos de datos (números, caracteres, etc) mientras que el resto solo puede contener un tipo de dato (solo carácteres, solo números, etc).\n\nSi no sabes que tipo de dato contiene una variable, se puede sar la función class()\n\nclass(x)      \n\n[1] \"numeric\"\n\nclass(caracter)     \n\n[1] \"character\"\n\n\n\n\n\n\n\n\n¿Funciones? 🤔\n\n\n\nR utiliza funciones para realizar operaciones, por ejemplo class(). Para utilizar una función deben especificarse determiandos argumentos, los cuales se escriben dentro del parentesis.\nUna ventaja de utilizar Rstudio, es que al abrir una función, automaticamente te desplegará las opciones de argumentos. Por ejemplo, escribe en la terminal round(). Tras completarse la función, te desplegara la información round(x, digits = 0) donde x es el objecto (número o vector) y digits es el número de decimales."
  },
  {
    "objectID": "1_Rbasico.html#indices",
    "href": "1_Rbasico.html#indices",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Indices",
    "text": "Indices\nUsar índices para obtener subconjuntos es el procedimiento más universal en R, pues funciona para todas las estructuras de datos.\nUn índice en R representa una posición. Cuando usamos índices le pedimos a R que extraiga de una estructura los datos que se encuentran en una o varias posiciones específicas dentro de ella.\nPara obtener subconjuntos con índices escribimos corchetes [] después del nombre de un objeto. Dentro de los corchetes escribimos el o los números que corresponden a la posición que nos interesa extraer del objeto.\n\nmortalidad[1]\n\nLunes \n    4 \n\n\nMostrar todos los valores excepto el segundo\n\nmortalidad[-2]\n\n    Lunes Miercoles    Jueves   Viernes    Sabado   Domingo \n        4         0        10        12         8         4 \n\n\nSe puede obtener multiples series de elementos al mismo tiempo usando c()\n\nmortalidad[c(1,2:4)]\n\n    Lunes    Martes Miercoles    Jueves \n        4         6         0        10 \n\n\no si por el contrario queremos eliminar estos elementos se usa c(-)\n\nmortalidad[-c(1,2:4)]\n\nViernes  Sabado Domingo \n     12       8       4 \n\n\nObtener los dias en donde la mortalidad fue mayor a 5\n\nmortalidad &gt; 5\n\n    Lunes    Martes Miercoles    Jueves   Viernes    Sabado   Domingo \n    FALSE      TRUE     FALSE      TRUE      TRUE      TRUE     FALSE \n\n#Mostrar solo los dias donde la mortalidad fue &gt; 5\nmortalidad[mortalidad &gt; 5]\n\n Martes  Jueves Viernes  Sabado \n      6      10      12       8 \n\n\nEjercicio\nIdentificar:\n\n¿En que dia se observó la menor mortalidad?\n¿Que dias tuvieron una mortalidad igual a 12?\n¿Que dias tuvieron una mortalidad menor al promedio?"
  },
  {
    "objectID": "1_Rbasico.html#acceder-a-elementos-de-un-data.frame",
    "href": "1_Rbasico.html#acceder-a-elementos-de-un-data.frame",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Acceder a elementos de un data.frame",
    "text": "Acceder a elementos de un data.frame\nPara acceder a los elementos de un data.frame podemos utilizar el simbolo $ o utilizando indices [F, C] donde el primer elemento antes de la coma, son las filas y el segundo elemento las columnas.\nPor ejemplo, para acceder al vector de los nombres\n\nmi_df$Nombre\n\n[1] \"Alex\"     \"Lilly\"    \"Mark\"     \"Oliver\"   \"Martha\"   \"Lucas\"    \"Caroline\"\n\n\no usando los indices\n\nmi_df[ , 1]\n\n[1] \"Alex\"     \"Lilly\"    \"Mark\"     \"Oliver\"   \"Martha\"   \"Lucas\"    \"Caroline\"\n\n\n\n\n\n\n\n\n\n\n\n\nPara acceder a todas las filas de una determinada columna, dejamos ese espacio en blanco antes de la coma. Por el contrario si queremos seleccionar la primera fila de todas las columnas utilizariamos:\n\nmi_df[1, ]\n\n  Nombre Edad Altura Peso Sexo\n1   Alex   25    177   57    M\n\n\n\n\no podemos usar el nombre de la columna dentro del indice\n\nmi_df[, \"Nombre\"]\n\n[1] \"Alex\"     \"Lilly\"    \"Mark\"     \"Oliver\"   \"Martha\"   \"Lucas\"    \"Caroline\""
  },
  {
    "objectID": "1_Rbasico.html#creación-de-matrices",
    "href": "1_Rbasico.html#creación-de-matrices",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Creación de matrices",
    "text": "Creación de matrices\nPara crear una matriz se usa la función matrix(), la cual usa los argumentos nrow y ncol. Con ellos se especifica el número de renglones y columnas que tendrá nuestra matriz.\n\n#matriz sin especificar renglones ni columnas\nmatrix(1:12)\n\n      [,1]\n [1,]    1\n [2,]    2\n [3,]    3\n [4,]    4\n [5,]    5\n [6,]    6\n [7,]    7\n [8,]    8\n [9,]    9\n[10,]   10\n[11,]   11\n[12,]   12\n\n\nAhora usamos la misma serie de números pero definiendo 3 filas y 4 columnas\n\nmatrix(1:12, nrow = 3, ncol = 4)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n\nAhora usando la misma serie de números pero con 4 filas y 3 columnas\n\nmatrix(1:12, nrow = 4, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\n\n\n¿Que pasa si definimos un menor número de filas y columnas que el número de elementos?\n¿Que pasa si usamos un número mayor de filas y columnas que el número total de elementos"
  },
  {
    "objectID": "1_Rbasico.html#arreglos",
    "href": "1_Rbasico.html#arreglos",
    "title": "R y Rstudio: Comandos Basicos",
    "section": "Arreglos",
    "text": "Arreglos\nson similares a las matrices pero pueden contener 2 o mas dimensiones\n\narreglo &lt;- array(1:24, dim = c(2,3,4))\narreglo\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n, , 3\n\n     [,1] [,2] [,3]\n[1,]   13   15   17\n[2,]   14   16   18\n\n, , 4\n\n     [,1] [,2] [,3]\n[1,]   19   21   23\n[2,]   20   22   24"
  }
]